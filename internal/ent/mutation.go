// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"kala/internal/ent/address"
	"kala/internal/ent/attribute"
	"kala/internal/ent/attributevalue"
	"kala/internal/ent/brand"
	"kala/internal/ent/category"
	"kala/internal/ent/comment"
	"kala/internal/ent/cons"
	"kala/internal/ent/image"
	"kala/internal/ent/logs"
	"kala/internal/ent/order"
	"kala/internal/ent/predicate"
	"kala/internal/ent/product"
	"kala/internal/ent/pros"
	"kala/internal/ent/seller"
	"kala/internal/ent/subcategory"
	"kala/internal/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddress        = "Address"
	TypeAttribute      = "Attribute"
	TypeAttributeValue = "AttributeValue"
	TypeBrand          = "Brand"
	TypeCategory       = "Category"
	TypeComment        = "Comment"
	TypeCons           = "Cons"
	TypeImage          = "Image"
	TypeLogs           = "Logs"
	TypeOrder          = "Order"
	TypeProduct        = "Product"
	TypePros           = "Pros"
	TypeSeller         = "Seller"
	TypeSubCategory    = "SubCategory"
	TypeUser           = "User"
)

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op            Op
	typ           string
	id            *int
	address       *string
	zip_code      *string
	phone         *string
	coordinates   *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	seller        *int
	clearedseller bool
	done          bool
	oldValue      func(context.Context) (*Address, error)
	predicates    []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id int) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *AddressMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AddressMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AddressMutation) ResetAddress() {
	m.address = nil
}

// SetZipCode sets the "zip_code" field.
func (m *AddressMutation) SetZipCode(s string) {
	m.zip_code = &s
}

// ZipCode returns the value of the "zip_code" field in the mutation.
func (m *AddressMutation) ZipCode() (r string, exists bool) {
	v := m.zip_code
	if v == nil {
		return
	}
	return *v, true
}

// OldZipCode returns the old "zip_code" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldZipCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipCode: %w", err)
	}
	return oldValue.ZipCode, nil
}

// ResetZipCode resets all changes to the "zip_code" field.
func (m *AddressMutation) ResetZipCode() {
	m.zip_code = nil
}

// SetPhone sets the "phone" field.
func (m *AddressMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AddressMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *AddressMutation) ResetPhone() {
	m.phone = nil
}

// SetCoordinates sets the "coordinates" field.
func (m *AddressMutation) SetCoordinates(s string) {
	m.coordinates = &s
}

// Coordinates returns the value of the "coordinates" field in the mutation.
func (m *AddressMutation) Coordinates() (r string, exists bool) {
	v := m.coordinates
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinates returns the old "coordinates" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCoordinates(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinates: %w", err)
	}
	return oldValue.Coordinates, nil
}

// ResetCoordinates resets all changes to the "coordinates" field.
func (m *AddressMutation) ResetCoordinates() {
	m.coordinates = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AddressMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AddressMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AddressMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AddressMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AddressMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetSellerID sets the "seller" edge to the Seller entity by id.
func (m *AddressMutation) SetSellerID(id int) {
	m.seller = &id
}

// ClearSeller clears the "seller" edge to the Seller entity.
func (m *AddressMutation) ClearSeller() {
	m.clearedseller = true
}

// SellerCleared reports if the "seller" edge to the Seller entity was cleared.
func (m *AddressMutation) SellerCleared() bool {
	return m.clearedseller
}

// SellerID returns the "seller" edge ID in the mutation.
func (m *AddressMutation) SellerID() (id int, exists bool) {
	if m.seller != nil {
		return *m.seller, true
	}
	return
}

// SellerIDs returns the "seller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) SellerIDs() (ids []int) {
	if id := m.seller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeller resets all changes to the "seller" edge.
func (m *AddressMutation) ResetSeller() {
	m.seller = nil
	m.clearedseller = false
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Address, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.address != nil {
		fields = append(fields, address.FieldAddress)
	}
	if m.zip_code != nil {
		fields = append(fields, address.FieldZipCode)
	}
	if m.phone != nil {
		fields = append(fields, address.FieldPhone)
	}
	if m.coordinates != nil {
		fields = append(fields, address.FieldCoordinates)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldAddress:
		return m.Address()
	case address.FieldZipCode:
		return m.ZipCode()
	case address.FieldPhone:
		return m.Phone()
	case address.FieldCoordinates:
		return m.Coordinates()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldAddress:
		return m.OldAddress(ctx)
	case address.FieldZipCode:
		return m.OldZipCode(ctx)
	case address.FieldPhone:
		return m.OldPhone(ctx)
	case address.FieldCoordinates:
		return m.OldCoordinates(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case address.FieldZipCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipCode(v)
		return nil
	case address.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case address.FieldCoordinates:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinates(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldAddress:
		m.ResetAddress()
		return nil
	case address.FieldZipCode:
		m.ResetZipCode()
		return nil
	case address.FieldPhone:
		m.ResetPhone()
		return nil
	case address.FieldCoordinates:
		m.ResetCoordinates()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, address.EdgeUser)
	}
	if m.seller != nil {
		edges = append(edges, address.EdgeSeller)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeSeller:
		if id := m.seller; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, address.EdgeUser)
	}
	if m.clearedseller {
		edges = append(edges, address.EdgeSeller)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeUser:
		return m.cleareduser
	case address.EdgeSeller:
		return m.clearedseller
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	case address.EdgeUser:
		m.ClearUser()
		return nil
	case address.EdgeSeller:
		m.ClearSeller()
		return nil
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeUser:
		m.ResetUser()
		return nil
	case address.EdgeSeller:
		m.ResetSeller()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// AttributeMutation represents an operation that mutates the Attribute nodes in the graph.
type AttributeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	values        map[int]struct{}
	removedvalues map[int]struct{}
	clearedvalues bool
	done          bool
	oldValue      func(context.Context) (*Attribute, error)
	predicates    []predicate.Attribute
}

var _ ent.Mutation = (*AttributeMutation)(nil)

// attributeOption allows management of the mutation configuration using functional options.
type attributeOption func(*AttributeMutation)

// newAttributeMutation creates new mutation for the Attribute entity.
func newAttributeMutation(c config, op Op, opts ...attributeOption) *AttributeMutation {
	m := &AttributeMutation{
		config:        c,
		op:            op,
		typ:           TypeAttribute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttributeID sets the ID field of the mutation.
func withAttributeID(id int) attributeOption {
	return func(m *AttributeMutation) {
		var (
			err   error
			once  sync.Once
			value *Attribute
		)
		m.oldValue = func(ctx context.Context) (*Attribute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attribute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttribute sets the old Attribute of the mutation.
func withAttribute(node *Attribute) attributeOption {
	return func(m *AttributeMutation) {
		m.oldValue = func(context.Context) (*Attribute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttributeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttributeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttributeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttributeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attribute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AttributeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AttributeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AttributeMutation) ResetName() {
	m.name = nil
}

// AddValueIDs adds the "values" edge to the AttributeValue entity by ids.
func (m *AttributeMutation) AddValueIDs(ids ...int) {
	if m.values == nil {
		m.values = make(map[int]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the AttributeValue entity.
func (m *AttributeMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the AttributeValue entity was cleared.
func (m *AttributeMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the AttributeValue entity by IDs.
func (m *AttributeMutation) RemoveValueIDs(ids ...int) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the AttributeValue entity.
func (m *AttributeMutation) RemovedValuesIDs() (ids []int) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *AttributeMutation) ValuesIDs() (ids []int) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *AttributeMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// Where appends a list predicates to the AttributeMutation builder.
func (m *AttributeMutation) Where(ps ...predicate.Attribute) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttributeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttributeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attribute, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttributeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttributeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attribute).
func (m *AttributeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttributeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, attribute.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttributeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attribute.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttributeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attribute.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Attribute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attribute.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttributeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttributeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attribute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttributeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttributeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttributeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Attribute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttributeMutation) ResetField(name string) error {
	switch name {
	case attribute.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttributeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.values != nil {
		edges = append(edges, attribute.EdgeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttributeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attribute.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttributeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvalues != nil {
		edges = append(edges, attribute.EdgeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttributeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case attribute.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttributeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvalues {
		edges = append(edges, attribute.EdgeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttributeMutation) EdgeCleared(name string) bool {
	switch name {
	case attribute.EdgeValues:
		return m.clearedvalues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttributeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Attribute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttributeMutation) ResetEdge(name string) error {
	switch name {
	case attribute.EdgeValues:
		m.ResetValues()
		return nil
	}
	return fmt.Errorf("unknown Attribute edge %s", name)
}

// AttributeValueMutation represents an operation that mutates the AttributeValue nodes in the graph.
type AttributeValueMutation struct {
	config
	op                Op
	typ               string
	id                *int
	value             *string
	clearedFields     map[string]struct{}
	attributes        *int
	clearedattributes bool
	products          *int
	clearedproducts   bool
	done              bool
	oldValue          func(context.Context) (*AttributeValue, error)
	predicates        []predicate.AttributeValue
}

var _ ent.Mutation = (*AttributeValueMutation)(nil)

// attributevalueOption allows management of the mutation configuration using functional options.
type attributevalueOption func(*AttributeValueMutation)

// newAttributeValueMutation creates new mutation for the AttributeValue entity.
func newAttributeValueMutation(c config, op Op, opts ...attributevalueOption) *AttributeValueMutation {
	m := &AttributeValueMutation{
		config:        c,
		op:            op,
		typ:           TypeAttributeValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttributeValueID sets the ID field of the mutation.
func withAttributeValueID(id int) attributevalueOption {
	return func(m *AttributeValueMutation) {
		var (
			err   error
			once  sync.Once
			value *AttributeValue
		)
		m.oldValue = func(ctx context.Context) (*AttributeValue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AttributeValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttributeValue sets the old AttributeValue of the mutation.
func withAttributeValue(node *AttributeValue) attributevalueOption {
	return func(m *AttributeValueMutation) {
		m.oldValue = func(context.Context) (*AttributeValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttributeValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttributeValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttributeValueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttributeValueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AttributeValue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *AttributeValueMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *AttributeValueMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AttributeValueMutation) ResetValue() {
	m.value = nil
}

// SetAttribute sets the "attribute" field.
func (m *AttributeValueMutation) SetAttribute(i int) {
	m.attributes = &i
}

// Attribute returns the value of the "attribute" field in the mutation.
func (m *AttributeValueMutation) Attribute() (r int, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttribute returns the old "attribute" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldAttribute(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttribute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttribute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttribute: %w", err)
	}
	return oldValue.Attribute, nil
}

// ResetAttribute resets all changes to the "attribute" field.
func (m *AttributeValueMutation) ResetAttribute() {
	m.attributes = nil
}

// SetProduct sets the "product" field.
func (m *AttributeValueMutation) SetProduct(i int) {
	m.products = &i
}

// Product returns the value of the "product" field in the mutation.
func (m *AttributeValueMutation) Product() (r int, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// OldProduct returns the old "product" field's value of the AttributeValue entity.
// If the AttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeValueMutation) OldProduct(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProduct is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProduct requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProduct: %w", err)
	}
	return oldValue.Product, nil
}

// ResetProduct resets all changes to the "product" field.
func (m *AttributeValueMutation) ResetProduct() {
	m.products = nil
}

// SetAttributesID sets the "attributes" edge to the Attribute entity by id.
func (m *AttributeValueMutation) SetAttributesID(id int) {
	m.attributes = &id
}

// ClearAttributes clears the "attributes" edge to the Attribute entity.
func (m *AttributeValueMutation) ClearAttributes() {
	m.clearedattributes = true
}

// AttributesCleared reports if the "attributes" edge to the Attribute entity was cleared.
func (m *AttributeValueMutation) AttributesCleared() bool {
	return m.clearedattributes
}

// AttributesID returns the "attributes" edge ID in the mutation.
func (m *AttributeValueMutation) AttributesID() (id int, exists bool) {
	if m.attributes != nil {
		return *m.attributes, true
	}
	return
}

// AttributesIDs returns the "attributes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AttributesID instead. It exists only for internal usage by the builders.
func (m *AttributeValueMutation) AttributesIDs() (ids []int) {
	if id := m.attributes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAttributes resets all changes to the "attributes" edge.
func (m *AttributeValueMutation) ResetAttributes() {
	m.attributes = nil
	m.clearedattributes = false
}

// SetProductsID sets the "products" edge to the Product entity by id.
func (m *AttributeValueMutation) SetProductsID(id int) {
	m.products = &id
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *AttributeValueMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *AttributeValueMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// ProductsID returns the "products" edge ID in the mutation.
func (m *AttributeValueMutation) ProductsID() (id int, exists bool) {
	if m.products != nil {
		return *m.products, true
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *AttributeValueMutation) ProductsIDs() (ids []int) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *AttributeValueMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// Where appends a list predicates to the AttributeValueMutation builder.
func (m *AttributeValueMutation) Where(ps ...predicate.AttributeValue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttributeValueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttributeValueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AttributeValue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttributeValueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttributeValueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AttributeValue).
func (m *AttributeValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttributeValueMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.value != nil {
		fields = append(fields, attributevalue.FieldValue)
	}
	if m.attributes != nil {
		fields = append(fields, attributevalue.FieldAttribute)
	}
	if m.products != nil {
		fields = append(fields, attributevalue.FieldProduct)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttributeValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attributevalue.FieldValue:
		return m.Value()
	case attributevalue.FieldAttribute:
		return m.Attribute()
	case attributevalue.FieldProduct:
		return m.Product()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttributeValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attributevalue.FieldValue:
		return m.OldValue(ctx)
	case attributevalue.FieldAttribute:
		return m.OldAttribute(ctx)
	case attributevalue.FieldProduct:
		return m.OldProduct(ctx)
	}
	return nil, fmt.Errorf("unknown AttributeValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attributevalue.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case attributevalue.FieldAttribute:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttribute(v)
		return nil
	case attributevalue.FieldProduct:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProduct(v)
		return nil
	}
	return fmt.Errorf("unknown AttributeValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttributeValueMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttributeValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AttributeValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttributeValueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttributeValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttributeValueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AttributeValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttributeValueMutation) ResetField(name string) error {
	switch name {
	case attributevalue.FieldValue:
		m.ResetValue()
		return nil
	case attributevalue.FieldAttribute:
		m.ResetAttribute()
		return nil
	case attributevalue.FieldProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown AttributeValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttributeValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attributes != nil {
		edges = append(edges, attributevalue.EdgeAttributes)
	}
	if m.products != nil {
		edges = append(edges, attributevalue.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttributeValueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attributevalue.EdgeAttributes:
		if id := m.attributes; id != nil {
			return []ent.Value{*id}
		}
	case attributevalue.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttributeValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttributeValueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttributeValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattributes {
		edges = append(edges, attributevalue.EdgeAttributes)
	}
	if m.clearedproducts {
		edges = append(edges, attributevalue.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttributeValueMutation) EdgeCleared(name string) bool {
	switch name {
	case attributevalue.EdgeAttributes:
		return m.clearedattributes
	case attributevalue.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttributeValueMutation) ClearEdge(name string) error {
	switch name {
	case attributevalue.EdgeAttributes:
		m.ClearAttributes()
		return nil
	case attributevalue.EdgeProducts:
		m.ClearProducts()
		return nil
	}
	return fmt.Errorf("unknown AttributeValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttributeValueMutation) ResetEdge(name string) error {
	switch name {
	case attributevalue.EdgeAttributes:
		m.ResetAttributes()
		return nil
	case attributevalue.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown AttributeValue edge %s", name)
}

// BrandMutation represents an operation that mutates the Brand nodes in the graph.
type BrandMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	name            *string
	description     *string
	status          *bool
	rating          *float64
	addrating       *float64
	rating_count    *int32
	addrating_count *int32
	clearedFields   map[string]struct{}
	image           map[int]struct{}
	removedimage    map[int]struct{}
	clearedimage    bool
	category        map[int]struct{}
	removedcategory map[int]struct{}
	clearedcategory bool
	product         map[int]struct{}
	removedproduct  map[int]struct{}
	clearedproduct  bool
	done            bool
	oldValue        func(context.Context) (*Brand, error)
	predicates      []predicate.Brand
}

var _ ent.Mutation = (*BrandMutation)(nil)

// brandOption allows management of the mutation configuration using functional options.
type brandOption func(*BrandMutation)

// newBrandMutation creates new mutation for the Brand entity.
func newBrandMutation(c config, op Op, opts ...brandOption) *BrandMutation {
	m := &BrandMutation{
		config:        c,
		op:            op,
		typ:           TypeBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBrandID sets the ID field of the mutation.
func withBrandID(id int) brandOption {
	return func(m *BrandMutation) {
		var (
			err   error
			once  sync.Once
			value *Brand
		)
		m.oldValue = func(ctx context.Context) (*Brand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Brand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBrand sets the old Brand of the mutation.
func withBrand(node *Brand) brandOption {
	return func(m *BrandMutation) {
		m.oldValue = func(context.Context) (*Brand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BrandMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BrandMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Brand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *BrandMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BrandMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BrandMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BrandMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BrandMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BrandMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *BrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BrandMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BrandMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BrandMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BrandMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *BrandMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BrandMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BrandMutation) ResetStatus() {
	m.status = nil
}

// SetRating sets the "rating" field.
func (m *BrandMutation) SetRating(f float64) {
	m.rating = &f
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *BrandMutation) Rating() (r float64, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds f to the "rating" field.
func (m *BrandMutation) AddRating(f float64) {
	if m.addrating != nil {
		*m.addrating += f
	} else {
		m.addrating = &f
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *BrandMutation) AddedRating() (r float64, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *BrandMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetRatingCount sets the "rating_count" field.
func (m *BrandMutation) SetRatingCount(i int32) {
	m.rating_count = &i
	m.addrating_count = nil
}

// RatingCount returns the value of the "rating_count" field in the mutation.
func (m *BrandMutation) RatingCount() (r int32, exists bool) {
	v := m.rating_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingCount returns the old "rating_count" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldRatingCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingCount: %w", err)
	}
	return oldValue.RatingCount, nil
}

// AddRatingCount adds i to the "rating_count" field.
func (m *BrandMutation) AddRatingCount(i int32) {
	if m.addrating_count != nil {
		*m.addrating_count += i
	} else {
		m.addrating_count = &i
	}
}

// AddedRatingCount returns the value that was added to the "rating_count" field in this mutation.
func (m *BrandMutation) AddedRatingCount() (r int32, exists bool) {
	v := m.addrating_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatingCount resets all changes to the "rating_count" field.
func (m *BrandMutation) ResetRatingCount() {
	m.rating_count = nil
	m.addrating_count = nil
}

// AddImageIDs adds the "image" edge to the Image entity by ids.
func (m *BrandMutation) AddImageIDs(ids ...int) {
	if m.image == nil {
		m.image = make(map[int]struct{})
	}
	for i := range ids {
		m.image[ids[i]] = struct{}{}
	}
}

// ClearImage clears the "image" edge to the Image entity.
func (m *BrandMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *BrandMutation) ImageCleared() bool {
	return m.clearedimage
}

// RemoveImageIDs removes the "image" edge to the Image entity by IDs.
func (m *BrandMutation) RemoveImageIDs(ids ...int) {
	if m.removedimage == nil {
		m.removedimage = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.image, ids[i])
		m.removedimage[ids[i]] = struct{}{}
	}
}

// RemovedImage returns the removed IDs of the "image" edge to the Image entity.
func (m *BrandMutation) RemovedImageIDs() (ids []int) {
	for id := range m.removedimage {
		ids = append(ids, id)
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
func (m *BrandMutation) ImageIDs() (ids []int) {
	for id := range m.image {
		ids = append(ids, id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *BrandMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
	m.removedimage = nil
}

// AddCategoryIDs adds the "category" edge to the Category entity by ids.
func (m *BrandMutation) AddCategoryIDs(ids ...int) {
	if m.category == nil {
		m.category = make(map[int]struct{})
	}
	for i := range ids {
		m.category[ids[i]] = struct{}{}
	}
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *BrandMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *BrandMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// RemoveCategoryIDs removes the "category" edge to the Category entity by IDs.
func (m *BrandMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategory == nil {
		m.removedcategory = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.category, ids[i])
		m.removedcategory[ids[i]] = struct{}{}
	}
}

// RemovedCategory returns the removed IDs of the "category" edge to the Category entity.
func (m *BrandMutation) RemovedCategoryIDs() (ids []int) {
	for id := range m.removedcategory {
		ids = append(ids, id)
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
func (m *BrandMutation) CategoryIDs() (ids []int) {
	for id := range m.category {
		ids = append(ids, id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *BrandMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
	m.removedcategory = nil
}

// AddProductIDs adds the "product" edge to the Product entity by ids.
func (m *BrandMutation) AddProductIDs(ids ...int) {
	if m.product == nil {
		m.product = make(map[int]struct{})
	}
	for i := range ids {
		m.product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *BrandMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *BrandMutation) ProductCleared() bool {
	return m.clearedproduct
}

// RemoveProductIDs removes the "product" edge to the Product entity by IDs.
func (m *BrandMutation) RemoveProductIDs(ids ...int) {
	if m.removedproduct == nil {
		m.removedproduct = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product, ids[i])
		m.removedproduct[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "product" edge to the Product entity.
func (m *BrandMutation) RemovedProductIDs() (ids []int) {
	for id := range m.removedproduct {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
func (m *BrandMutation) ProductIDs() (ids []int) {
	for id := range m.product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *BrandMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
	m.removedproduct = nil
}

// Where appends a list predicates to the BrandMutation builder.
func (m *BrandMutation) Where(ps ...predicate.Brand) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BrandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BrandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Brand, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BrandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BrandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Brand).
func (m *BrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BrandMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, brand.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, brand.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, brand.FieldName)
	}
	if m.description != nil {
		fields = append(fields, brand.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, brand.FieldStatus)
	}
	if m.rating != nil {
		fields = append(fields, brand.FieldRating)
	}
	if m.rating_count != nil {
		fields = append(fields, brand.FieldRatingCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case brand.FieldCreateTime:
		return m.CreateTime()
	case brand.FieldUpdateTime:
		return m.UpdateTime()
	case brand.FieldName:
		return m.Name()
	case brand.FieldDescription:
		return m.Description()
	case brand.FieldStatus:
		return m.Status()
	case brand.FieldRating:
		return m.Rating()
	case brand.FieldRatingCount:
		return m.RatingCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case brand.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case brand.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case brand.FieldName:
		return m.OldName(ctx)
	case brand.FieldDescription:
		return m.OldDescription(ctx)
	case brand.FieldStatus:
		return m.OldStatus(ctx)
	case brand.FieldRating:
		return m.OldRating(ctx)
	case brand.FieldRatingCount:
		return m.OldRatingCount(ctx)
	}
	return nil, fmt.Errorf("unknown Brand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case brand.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case brand.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case brand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case brand.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case brand.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case brand.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case brand.FieldRatingCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingCount(v)
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BrandMutation) AddedFields() []string {
	var fields []string
	if m.addrating != nil {
		fields = append(fields, brand.FieldRating)
	}
	if m.addrating_count != nil {
		fields = append(fields, brand.FieldRatingCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BrandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case brand.FieldRating:
		return m.AddedRating()
	case brand.FieldRatingCount:
		return m.AddedRatingCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	case brand.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	case brand.FieldRatingCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatingCount(v)
		return nil
	}
	return fmt.Errorf("unknown Brand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BrandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BrandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Brand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BrandMutation) ResetField(name string) error {
	switch name {
	case brand.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case brand.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case brand.FieldName:
		m.ResetName()
		return nil
	case brand.FieldDescription:
		m.ResetDescription()
		return nil
	case brand.FieldStatus:
		m.ResetStatus()
		return nil
	case brand.FieldRating:
		m.ResetRating()
		return nil
	case brand.FieldRatingCount:
		m.ResetRatingCount()
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.image != nil {
		edges = append(edges, brand.EdgeImage)
	}
	if m.category != nil {
		edges = append(edges, brand.EdgeCategory)
	}
	if m.product != nil {
		edges = append(edges, brand.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeImage:
		ids := make([]ent.Value, 0, len(m.image))
		for id := range m.image {
			ids = append(ids, id)
		}
		return ids
	case brand.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.category))
		for id := range m.category {
			ids = append(ids, id)
		}
		return ids
	case brand.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.product))
		for id := range m.product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedimage != nil {
		edges = append(edges, brand.EdgeImage)
	}
	if m.removedcategory != nil {
		edges = append(edges, brand.EdgeCategory)
	}
	if m.removedproduct != nil {
		edges = append(edges, brand.EdgeProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeImage:
		ids := make([]ent.Value, 0, len(m.removedimage))
		for id := range m.removedimage {
			ids = append(ids, id)
		}
		return ids
	case brand.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.removedcategory))
		for id := range m.removedcategory {
			ids = append(ids, id)
		}
		return ids
	case brand.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removedproduct))
		for id := range m.removedproduct {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedimage {
		edges = append(edges, brand.EdgeImage)
	}
	if m.clearedcategory {
		edges = append(edges, brand.EdgeCategory)
	}
	if m.clearedproduct {
		edges = append(edges, brand.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BrandMutation) EdgeCleared(name string) bool {
	switch name {
	case brand.EdgeImage:
		return m.clearedimage
	case brand.EdgeCategory:
		return m.clearedcategory
	case brand.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BrandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BrandMutation) ResetEdge(name string) error {
	switch name {
	case brand.EdgeImage:
		m.ResetImage()
		return nil
	case brand.EdgeCategory:
		m.ResetCategory()
		return nil
	case brand.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Brand edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	name                *string
	description         *string
	clearedFields       map[string]struct{}
	sub_category        map[int]struct{}
	removedsub_category map[int]struct{}
	clearedsub_category bool
	brand               map[int]struct{}
	removedbrand        map[int]struct{}
	clearedbrand        bool
	seller              map[int]struct{}
	removedseller       map[int]struct{}
	clearedseller       bool
	done                bool
	oldValue            func(context.Context) (*Category, error)
	predicates          []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
}

// AddSubCategoryIDs adds the "sub_category" edge to the SubCategory entity by ids.
func (m *CategoryMutation) AddSubCategoryIDs(ids ...int) {
	if m.sub_category == nil {
		m.sub_category = make(map[int]struct{})
	}
	for i := range ids {
		m.sub_category[ids[i]] = struct{}{}
	}
}

// ClearSubCategory clears the "sub_category" edge to the SubCategory entity.
func (m *CategoryMutation) ClearSubCategory() {
	m.clearedsub_category = true
}

// SubCategoryCleared reports if the "sub_category" edge to the SubCategory entity was cleared.
func (m *CategoryMutation) SubCategoryCleared() bool {
	return m.clearedsub_category
}

// RemoveSubCategoryIDs removes the "sub_category" edge to the SubCategory entity by IDs.
func (m *CategoryMutation) RemoveSubCategoryIDs(ids ...int) {
	if m.removedsub_category == nil {
		m.removedsub_category = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sub_category, ids[i])
		m.removedsub_category[ids[i]] = struct{}{}
	}
}

// RemovedSubCategory returns the removed IDs of the "sub_category" edge to the SubCategory entity.
func (m *CategoryMutation) RemovedSubCategoryIDs() (ids []int) {
	for id := range m.removedsub_category {
		ids = append(ids, id)
	}
	return
}

// SubCategoryIDs returns the "sub_category" edge IDs in the mutation.
func (m *CategoryMutation) SubCategoryIDs() (ids []int) {
	for id := range m.sub_category {
		ids = append(ids, id)
	}
	return
}

// ResetSubCategory resets all changes to the "sub_category" edge.
func (m *CategoryMutation) ResetSubCategory() {
	m.sub_category = nil
	m.clearedsub_category = false
	m.removedsub_category = nil
}

// AddBrandIDs adds the "brand" edge to the Brand entity by ids.
func (m *CategoryMutation) AddBrandIDs(ids ...int) {
	if m.brand == nil {
		m.brand = make(map[int]struct{})
	}
	for i := range ids {
		m.brand[ids[i]] = struct{}{}
	}
}

// ClearBrand clears the "brand" edge to the Brand entity.
func (m *CategoryMutation) ClearBrand() {
	m.clearedbrand = true
}

// BrandCleared reports if the "brand" edge to the Brand entity was cleared.
func (m *CategoryMutation) BrandCleared() bool {
	return m.clearedbrand
}

// RemoveBrandIDs removes the "brand" edge to the Brand entity by IDs.
func (m *CategoryMutation) RemoveBrandIDs(ids ...int) {
	if m.removedbrand == nil {
		m.removedbrand = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.brand, ids[i])
		m.removedbrand[ids[i]] = struct{}{}
	}
}

// RemovedBrand returns the removed IDs of the "brand" edge to the Brand entity.
func (m *CategoryMutation) RemovedBrandIDs() (ids []int) {
	for id := range m.removedbrand {
		ids = append(ids, id)
	}
	return
}

// BrandIDs returns the "brand" edge IDs in the mutation.
func (m *CategoryMutation) BrandIDs() (ids []int) {
	for id := range m.brand {
		ids = append(ids, id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *CategoryMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
	m.removedbrand = nil
}

// AddSellerIDs adds the "seller" edge to the Seller entity by ids.
func (m *CategoryMutation) AddSellerIDs(ids ...int) {
	if m.seller == nil {
		m.seller = make(map[int]struct{})
	}
	for i := range ids {
		m.seller[ids[i]] = struct{}{}
	}
}

// ClearSeller clears the "seller" edge to the Seller entity.
func (m *CategoryMutation) ClearSeller() {
	m.clearedseller = true
}

// SellerCleared reports if the "seller" edge to the Seller entity was cleared.
func (m *CategoryMutation) SellerCleared() bool {
	return m.clearedseller
}

// RemoveSellerIDs removes the "seller" edge to the Seller entity by IDs.
func (m *CategoryMutation) RemoveSellerIDs(ids ...int) {
	if m.removedseller == nil {
		m.removedseller = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller, ids[i])
		m.removedseller[ids[i]] = struct{}{}
	}
}

// RemovedSeller returns the removed IDs of the "seller" edge to the Seller entity.
func (m *CategoryMutation) RemovedSellerIDs() (ids []int) {
	for id := range m.removedseller {
		ids = append(ids, id)
	}
	return
}

// SellerIDs returns the "seller" edge IDs in the mutation.
func (m *CategoryMutation) SellerIDs() (ids []int) {
	for id := range m.seller {
		ids = append(ids, id)
	}
	return
}

// ResetSeller resets all changes to the "seller" edge.
func (m *CategoryMutation) ResetSeller() {
	m.seller = nil
	m.clearedseller = false
	m.removedseller = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, category.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, category.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreateTime:
		return m.CreateTime()
	case category.FieldUpdateTime:
		return m.UpdateTime()
	case category.FieldName:
		return m.Name()
	case category.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case category.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case category.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case category.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.sub_category != nil {
		edges = append(edges, category.EdgeSubCategory)
	}
	if m.brand != nil {
		edges = append(edges, category.EdgeBrand)
	}
	if m.seller != nil {
		edges = append(edges, category.EdgeSeller)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeSubCategory:
		ids := make([]ent.Value, 0, len(m.sub_category))
		for id := range m.sub_category {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeBrand:
		ids := make([]ent.Value, 0, len(m.brand))
		for id := range m.brand {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeSeller:
		ids := make([]ent.Value, 0, len(m.seller))
		for id := range m.seller {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsub_category != nil {
		edges = append(edges, category.EdgeSubCategory)
	}
	if m.removedbrand != nil {
		edges = append(edges, category.EdgeBrand)
	}
	if m.removedseller != nil {
		edges = append(edges, category.EdgeSeller)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeSubCategory:
		ids := make([]ent.Value, 0, len(m.removedsub_category))
		for id := range m.removedsub_category {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeBrand:
		ids := make([]ent.Value, 0, len(m.removedbrand))
		for id := range m.removedbrand {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeSeller:
		ids := make([]ent.Value, 0, len(m.removedseller))
		for id := range m.removedseller {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsub_category {
		edges = append(edges, category.EdgeSubCategory)
	}
	if m.clearedbrand {
		edges = append(edges, category.EdgeBrand)
	}
	if m.clearedseller {
		edges = append(edges, category.EdgeSeller)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeSubCategory:
		return m.clearedsub_category
	case category.EdgeBrand:
		return m.clearedbrand
	case category.EdgeSeller:
		return m.clearedseller
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeSubCategory:
		m.ResetSubCategory()
		return nil
	case category.EdgeBrand:
		m.ResetBrand()
		return nil
	case category.EdgeSeller:
		m.ResetSeller()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	content         *string
	status          *comment.Status
	likes           *int32
	addlikes        *int32
	dislikes        *int32
	adddislikes     *int32
	rating          *int8
	addrating       *int8
	rating_count    *int32
	addrating_count *int32
	verified_buyer  *bool
	clearedFields   map[string]struct{}
	image           map[int]struct{}
	removedimage    map[int]struct{}
	clearedimage    bool
	cons            map[int]struct{}
	removedcons     map[int]struct{}
	clearedcons     bool
	pros            map[int]struct{}
	removedpros     map[int]struct{}
	clearedpros     bool
	user            map[int]struct{}
	removeduser     map[int]struct{}
	cleareduser     bool
	product         map[int]struct{}
	removedproduct  map[int]struct{}
	clearedproduct  bool
	done            bool
	oldValue        func(context.Context) (*Comment, error)
	predicates      []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CommentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CommentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CommentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CommentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CommentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CommentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
}

// SetStatus sets the "status" field.
func (m *CommentMutation) SetStatus(c comment.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CommentMutation) Status() (r comment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldStatus(ctx context.Context) (v comment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CommentMutation) ResetStatus() {
	m.status = nil
}

// SetLikes sets the "likes" field.
func (m *CommentMutation) SetLikes(i int32) {
	m.likes = &i
	m.addlikes = nil
}

// Likes returns the value of the "likes" field in the mutation.
func (m *CommentMutation) Likes() (r int32, exists bool) {
	v := m.likes
	if v == nil {
		return
	}
	return *v, true
}

// OldLikes returns the old "likes" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldLikes(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikes: %w", err)
	}
	return oldValue.Likes, nil
}

// AddLikes adds i to the "likes" field.
func (m *CommentMutation) AddLikes(i int32) {
	if m.addlikes != nil {
		*m.addlikes += i
	} else {
		m.addlikes = &i
	}
}

// AddedLikes returns the value that was added to the "likes" field in this mutation.
func (m *CommentMutation) AddedLikes() (r int32, exists bool) {
	v := m.addlikes
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikes resets all changes to the "likes" field.
func (m *CommentMutation) ResetLikes() {
	m.likes = nil
	m.addlikes = nil
}

// SetDislikes sets the "dislikes" field.
func (m *CommentMutation) SetDislikes(i int32) {
	m.dislikes = &i
	m.adddislikes = nil
}

// Dislikes returns the value of the "dislikes" field in the mutation.
func (m *CommentMutation) Dislikes() (r int32, exists bool) {
	v := m.dislikes
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikes returns the old "dislikes" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDislikes(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikes: %w", err)
	}
	return oldValue.Dislikes, nil
}

// AddDislikes adds i to the "dislikes" field.
func (m *CommentMutation) AddDislikes(i int32) {
	if m.adddislikes != nil {
		*m.adddislikes += i
	} else {
		m.adddislikes = &i
	}
}

// AddedDislikes returns the value that was added to the "dislikes" field in this mutation.
func (m *CommentMutation) AddedDislikes() (r int32, exists bool) {
	v := m.adddislikes
	if v == nil {
		return
	}
	return *v, true
}

// ResetDislikes resets all changes to the "dislikes" field.
func (m *CommentMutation) ResetDislikes() {
	m.dislikes = nil
	m.adddislikes = nil
}

// SetRating sets the "rating" field.
func (m *CommentMutation) SetRating(i int8) {
	m.rating = &i
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *CommentMutation) Rating() (r int8, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldRating(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds i to the "rating" field.
func (m *CommentMutation) AddRating(i int8) {
	if m.addrating != nil {
		*m.addrating += i
	} else {
		m.addrating = &i
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *CommentMutation) AddedRating() (r int8, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *CommentMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetRatingCount sets the "rating_count" field.
func (m *CommentMutation) SetRatingCount(i int32) {
	m.rating_count = &i
	m.addrating_count = nil
}

// RatingCount returns the value of the "rating_count" field in the mutation.
func (m *CommentMutation) RatingCount() (r int32, exists bool) {
	v := m.rating_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingCount returns the old "rating_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldRatingCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingCount: %w", err)
	}
	return oldValue.RatingCount, nil
}

// AddRatingCount adds i to the "rating_count" field.
func (m *CommentMutation) AddRatingCount(i int32) {
	if m.addrating_count != nil {
		*m.addrating_count += i
	} else {
		m.addrating_count = &i
	}
}

// AddedRatingCount returns the value that was added to the "rating_count" field in this mutation.
func (m *CommentMutation) AddedRatingCount() (r int32, exists bool) {
	v := m.addrating_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatingCount resets all changes to the "rating_count" field.
func (m *CommentMutation) ResetRatingCount() {
	m.rating_count = nil
	m.addrating_count = nil
}

// SetVerifiedBuyer sets the "verified_buyer" field.
func (m *CommentMutation) SetVerifiedBuyer(b bool) {
	m.verified_buyer = &b
}

// VerifiedBuyer returns the value of the "verified_buyer" field in the mutation.
func (m *CommentMutation) VerifiedBuyer() (r bool, exists bool) {
	v := m.verified_buyer
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedBuyer returns the old "verified_buyer" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldVerifiedBuyer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedBuyer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedBuyer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedBuyer: %w", err)
	}
	return oldValue.VerifiedBuyer, nil
}

// ResetVerifiedBuyer resets all changes to the "verified_buyer" field.
func (m *CommentMutation) ResetVerifiedBuyer() {
	m.verified_buyer = nil
}

// AddImageIDs adds the "image" edge to the Image entity by ids.
func (m *CommentMutation) AddImageIDs(ids ...int) {
	if m.image == nil {
		m.image = make(map[int]struct{})
	}
	for i := range ids {
		m.image[ids[i]] = struct{}{}
	}
}

// ClearImage clears the "image" edge to the Image entity.
func (m *CommentMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *CommentMutation) ImageCleared() bool {
	return m.clearedimage
}

// RemoveImageIDs removes the "image" edge to the Image entity by IDs.
func (m *CommentMutation) RemoveImageIDs(ids ...int) {
	if m.removedimage == nil {
		m.removedimage = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.image, ids[i])
		m.removedimage[ids[i]] = struct{}{}
	}
}

// RemovedImage returns the removed IDs of the "image" edge to the Image entity.
func (m *CommentMutation) RemovedImageIDs() (ids []int) {
	for id := range m.removedimage {
		ids = append(ids, id)
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
func (m *CommentMutation) ImageIDs() (ids []int) {
	for id := range m.image {
		ids = append(ids, id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *CommentMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
	m.removedimage = nil
}

// AddConIDs adds the "cons" edge to the Cons entity by ids.
func (m *CommentMutation) AddConIDs(ids ...int) {
	if m.cons == nil {
		m.cons = make(map[int]struct{})
	}
	for i := range ids {
		m.cons[ids[i]] = struct{}{}
	}
}

// ClearCons clears the "cons" edge to the Cons entity.
func (m *CommentMutation) ClearCons() {
	m.clearedcons = true
}

// ConsCleared reports if the "cons" edge to the Cons entity was cleared.
func (m *CommentMutation) ConsCleared() bool {
	return m.clearedcons
}

// RemoveConIDs removes the "cons" edge to the Cons entity by IDs.
func (m *CommentMutation) RemoveConIDs(ids ...int) {
	if m.removedcons == nil {
		m.removedcons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cons, ids[i])
		m.removedcons[ids[i]] = struct{}{}
	}
}

// RemovedCons returns the removed IDs of the "cons" edge to the Cons entity.
func (m *CommentMutation) RemovedConsIDs() (ids []int) {
	for id := range m.removedcons {
		ids = append(ids, id)
	}
	return
}

// ConsIDs returns the "cons" edge IDs in the mutation.
func (m *CommentMutation) ConsIDs() (ids []int) {
	for id := range m.cons {
		ids = append(ids, id)
	}
	return
}

// ResetCons resets all changes to the "cons" edge.
func (m *CommentMutation) ResetCons() {
	m.cons = nil
	m.clearedcons = false
	m.removedcons = nil
}

// AddProIDs adds the "pros" edge to the Pros entity by ids.
func (m *CommentMutation) AddProIDs(ids ...int) {
	if m.pros == nil {
		m.pros = make(map[int]struct{})
	}
	for i := range ids {
		m.pros[ids[i]] = struct{}{}
	}
}

// ClearPros clears the "pros" edge to the Pros entity.
func (m *CommentMutation) ClearPros() {
	m.clearedpros = true
}

// ProsCleared reports if the "pros" edge to the Pros entity was cleared.
func (m *CommentMutation) ProsCleared() bool {
	return m.clearedpros
}

// RemoveProIDs removes the "pros" edge to the Pros entity by IDs.
func (m *CommentMutation) RemoveProIDs(ids ...int) {
	if m.removedpros == nil {
		m.removedpros = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pros, ids[i])
		m.removedpros[ids[i]] = struct{}{}
	}
}

// RemovedPros returns the removed IDs of the "pros" edge to the Pros entity.
func (m *CommentMutation) RemovedProsIDs() (ids []int) {
	for id := range m.removedpros {
		ids = append(ids, id)
	}
	return
}

// ProsIDs returns the "pros" edge IDs in the mutation.
func (m *CommentMutation) ProsIDs() (ids []int) {
	for id := range m.pros {
		ids = append(ids, id)
	}
	return
}

// ResetPros resets all changes to the "pros" edge.
func (m *CommentMutation) ResetPros() {
	m.pros = nil
	m.clearedpros = false
	m.removedpros = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *CommentMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *CommentMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *CommentMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *CommentMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddProductIDs adds the "product" edge to the Product entity by ids.
func (m *CommentMutation) AddProductIDs(ids ...int) {
	if m.product == nil {
		m.product = make(map[int]struct{})
	}
	for i := range ids {
		m.product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *CommentMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *CommentMutation) ProductCleared() bool {
	return m.clearedproduct
}

// RemoveProductIDs removes the "product" edge to the Product entity by IDs.
func (m *CommentMutation) RemoveProductIDs(ids ...int) {
	if m.removedproduct == nil {
		m.removedproduct = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product, ids[i])
		m.removedproduct[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "product" edge to the Product entity.
func (m *CommentMutation) RemovedProductIDs() (ids []int) {
	for id := range m.removedproduct {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
func (m *CommentMutation) ProductIDs() (ids []int) {
	for id := range m.product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *CommentMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
	m.removedproduct = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, comment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, comment.FieldUpdateTime)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.likes != nil {
		fields = append(fields, comment.FieldLikes)
	}
	if m.dislikes != nil {
		fields = append(fields, comment.FieldDislikes)
	}
	if m.rating != nil {
		fields = append(fields, comment.FieldRating)
	}
	if m.rating_count != nil {
		fields = append(fields, comment.FieldRatingCount)
	}
	if m.verified_buyer != nil {
		fields = append(fields, comment.FieldVerifiedBuyer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreateTime:
		return m.CreateTime()
	case comment.FieldUpdateTime:
		return m.UpdateTime()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldStatus:
		return m.Status()
	case comment.FieldLikes:
		return m.Likes()
	case comment.FieldDislikes:
		return m.Dislikes()
	case comment.FieldRating:
		return m.Rating()
	case comment.FieldRatingCount:
		return m.RatingCount()
	case comment.FieldVerifiedBuyer:
		return m.VerifiedBuyer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case comment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldStatus:
		return m.OldStatus(ctx)
	case comment.FieldLikes:
		return m.OldLikes(ctx)
	case comment.FieldDislikes:
		return m.OldDislikes(ctx)
	case comment.FieldRating:
		return m.OldRating(ctx)
	case comment.FieldRatingCount:
		return m.OldRatingCount(ctx)
	case comment.FieldVerifiedBuyer:
		return m.OldVerifiedBuyer(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case comment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(comment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case comment.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikes(v)
		return nil
	case comment.FieldDislikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikes(v)
		return nil
	case comment.FieldRating:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case comment.FieldRatingCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingCount(v)
		return nil
	case comment.FieldVerifiedBuyer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedBuyer(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addlikes != nil {
		fields = append(fields, comment.FieldLikes)
	}
	if m.adddislikes != nil {
		fields = append(fields, comment.FieldDislikes)
	}
	if m.addrating != nil {
		fields = append(fields, comment.FieldRating)
	}
	if m.addrating_count != nil {
		fields = append(fields, comment.FieldRatingCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldLikes:
		return m.AddedLikes()
	case comment.FieldDislikes:
		return m.AddedDislikes()
	case comment.FieldRating:
		return m.AddedRating()
	case comment.FieldRatingCount:
		return m.AddedRatingCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldLikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikes(v)
		return nil
	case comment.FieldDislikes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikes(v)
		return nil
	case comment.FieldRating:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	case comment.FieldRatingCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatingCount(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case comment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldStatus:
		m.ResetStatus()
		return nil
	case comment.FieldLikes:
		m.ResetLikes()
		return nil
	case comment.FieldDislikes:
		m.ResetDislikes()
		return nil
	case comment.FieldRating:
		m.ResetRating()
		return nil
	case comment.FieldRatingCount:
		m.ResetRatingCount()
		return nil
	case comment.FieldVerifiedBuyer:
		m.ResetVerifiedBuyer()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.image != nil {
		edges = append(edges, comment.EdgeImage)
	}
	if m.cons != nil {
		edges = append(edges, comment.EdgeCons)
	}
	if m.pros != nil {
		edges = append(edges, comment.EdgePros)
	}
	if m.user != nil {
		edges = append(edges, comment.EdgeUser)
	}
	if m.product != nil {
		edges = append(edges, comment.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeImage:
		ids := make([]ent.Value, 0, len(m.image))
		for id := range m.image {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeCons:
		ids := make([]ent.Value, 0, len(m.cons))
		for id := range m.cons {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgePros:
		ids := make([]ent.Value, 0, len(m.pros))
		for id := range m.pros {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.product))
		for id := range m.product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedimage != nil {
		edges = append(edges, comment.EdgeImage)
	}
	if m.removedcons != nil {
		edges = append(edges, comment.EdgeCons)
	}
	if m.removedpros != nil {
		edges = append(edges, comment.EdgePros)
	}
	if m.removeduser != nil {
		edges = append(edges, comment.EdgeUser)
	}
	if m.removedproduct != nil {
		edges = append(edges, comment.EdgeProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeImage:
		ids := make([]ent.Value, 0, len(m.removedimage))
		for id := range m.removedimage {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeCons:
		ids := make([]ent.Value, 0, len(m.removedcons))
		for id := range m.removedcons {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgePros:
		ids := make([]ent.Value, 0, len(m.removedpros))
		for id := range m.removedpros {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removedproduct))
		for id := range m.removedproduct {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedimage {
		edges = append(edges, comment.EdgeImage)
	}
	if m.clearedcons {
		edges = append(edges, comment.EdgeCons)
	}
	if m.clearedpros {
		edges = append(edges, comment.EdgePros)
	}
	if m.cleareduser {
		edges = append(edges, comment.EdgeUser)
	}
	if m.clearedproduct {
		edges = append(edges, comment.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeImage:
		return m.clearedimage
	case comment.EdgeCons:
		return m.clearedcons
	case comment.EdgePros:
		return m.clearedpros
	case comment.EdgeUser:
		return m.cleareduser
	case comment.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeImage:
		m.ResetImage()
		return nil
	case comment.EdgeCons:
		m.ResetCons()
		return nil
	case comment.EdgePros:
		m.ResetPros()
		return nil
	case comment.EdgeUser:
		m.ResetUser()
		return nil
	case comment.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// ConsMutation represents an operation that mutates the Cons nodes in the graph.
type ConsMutation struct {
	config
	op             Op
	typ            string
	id             *int
	con            *string
	clearedFields  map[string]struct{}
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*Cons, error)
	predicates     []predicate.Cons
}

var _ ent.Mutation = (*ConsMutation)(nil)

// consOption allows management of the mutation configuration using functional options.
type consOption func(*ConsMutation)

// newConsMutation creates new mutation for the Cons entity.
func newConsMutation(c config, op Op, opts ...consOption) *ConsMutation {
	m := &ConsMutation{
		config:        c,
		op:            op,
		typ:           TypeCons,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConsID sets the ID field of the mutation.
func withConsID(id int) consOption {
	return func(m *ConsMutation) {
		var (
			err   error
			once  sync.Once
			value *Cons
		)
		m.oldValue = func(ctx context.Context) (*Cons, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cons.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCons sets the old Cons of the mutation.
func withCons(node *Cons) consOption {
	return func(m *ConsMutation) {
		m.oldValue = func(context.Context) (*Cons, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cons.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCon sets the "con" field.
func (m *ConsMutation) SetCon(s string) {
	m.con = &s
}

// Con returns the value of the "con" field in the mutation.
func (m *ConsMutation) Con() (r string, exists bool) {
	v := m.con
	if v == nil {
		return
	}
	return *v, true
}

// OldCon returns the old "con" field's value of the Cons entity.
// If the Cons object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsMutation) OldCon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCon: %w", err)
	}
	return oldValue.Con, nil
}

// ResetCon resets all changes to the "con" field.
func (m *ConsMutation) ResetCon() {
	m.con = nil
}

// SetCommentID sets the "comment" edge to the Comment entity by id.
func (m *ConsMutation) SetCommentID(id int) {
	m.comment = &id
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *ConsMutation) ClearComment() {
	m.clearedcomment = true
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *ConsMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentID returns the "comment" edge ID in the mutation.
func (m *ConsMutation) CommentID() (id int, exists bool) {
	if m.comment != nil {
		return *m.comment, true
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *ConsMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *ConsMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the ConsMutation builder.
func (m *ConsMutation) Where(ps ...predicate.Cons) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cons, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cons).
func (m *ConsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.con != nil {
		fields = append(fields, cons.FieldCon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cons.FieldCon:
		return m.Con()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cons.FieldCon:
		return m.OldCon(ctx)
	}
	return nil, fmt.Errorf("unknown Cons field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cons.FieldCon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCon(v)
		return nil
	}
	return fmt.Errorf("unknown Cons field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cons numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cons nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConsMutation) ResetField(name string) error {
	switch name {
	case cons.FieldCon:
		m.ResetCon()
		return nil
	}
	return fmt.Errorf("unknown Cons field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.comment != nil {
		edges = append(edges, cons.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cons.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomment {
		edges = append(edges, cons.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConsMutation) EdgeCleared(name string) bool {
	switch name {
	case cons.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConsMutation) ClearEdge(name string) error {
	switch name {
	case cons.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown Cons unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConsMutation) ResetEdge(name string) error {
	switch name {
	case cons.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown Cons edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	_path          *string
	caption        *string
	width          *int32
	addwidth       *int32
	high           *int32
	addhigh        *int32
	size_kb        *float64
	addsize_kb     *float64
	uploaded_at    *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	comment        *int
	clearedcomment bool
	brand          *int
	clearedbrand   bool
	product        *int
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*Image, error)
	predicates     []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id int) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ImageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImageMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *ImageMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ImageMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *ImageMutation) ResetPath() {
	m._path = nil
}

// SetCaption sets the "caption" field.
func (m *ImageMutation) SetCaption(s string) {
	m.caption = &s
}

// Caption returns the value of the "caption" field in the mutation.
func (m *ImageMutation) Caption() (r string, exists bool) {
	v := m.caption
	if v == nil {
		return
	}
	return *v, true
}

// OldCaption returns the old "caption" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCaption(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaption: %w", err)
	}
	return oldValue.Caption, nil
}

// ClearCaption clears the value of the "caption" field.
func (m *ImageMutation) ClearCaption() {
	m.caption = nil
	m.clearedFields[image.FieldCaption] = struct{}{}
}

// CaptionCleared returns if the "caption" field was cleared in this mutation.
func (m *ImageMutation) CaptionCleared() bool {
	_, ok := m.clearedFields[image.FieldCaption]
	return ok
}

// ResetCaption resets all changes to the "caption" field.
func (m *ImageMutation) ResetCaption() {
	m.caption = nil
	delete(m.clearedFields, image.FieldCaption)
}

// SetWidth sets the "width" field.
func (m *ImageMutation) SetWidth(i int32) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *ImageMutation) Width() (r int32, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldWidth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *ImageMutation) AddWidth(i int32) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *ImageMutation) AddedWidth() (r int32, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *ImageMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHigh sets the "high" field.
func (m *ImageMutation) SetHigh(i int32) {
	m.high = &i
	m.addhigh = nil
}

// High returns the value of the "high" field in the mutation.
func (m *ImageMutation) High() (r int32, exists bool) {
	v := m.high
	if v == nil {
		return
	}
	return *v, true
}

// OldHigh returns the old "high" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldHigh(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHigh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHigh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHigh: %w", err)
	}
	return oldValue.High, nil
}

// AddHigh adds i to the "high" field.
func (m *ImageMutation) AddHigh(i int32) {
	if m.addhigh != nil {
		*m.addhigh += i
	} else {
		m.addhigh = &i
	}
}

// AddedHigh returns the value that was added to the "high" field in this mutation.
func (m *ImageMutation) AddedHigh() (r int32, exists bool) {
	v := m.addhigh
	if v == nil {
		return
	}
	return *v, true
}

// ResetHigh resets all changes to the "high" field.
func (m *ImageMutation) ResetHigh() {
	m.high = nil
	m.addhigh = nil
}

// SetSizeKB sets the "size_kb" field.
func (m *ImageMutation) SetSizeKB(f float64) {
	m.size_kb = &f
	m.addsize_kb = nil
}

// SizeKB returns the value of the "size_kb" field in the mutation.
func (m *ImageMutation) SizeKB() (r float64, exists bool) {
	v := m.size_kb
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeKB returns the old "size_kb" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldSizeKB(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeKB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeKB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeKB: %w", err)
	}
	return oldValue.SizeKB, nil
}

// AddSizeKB adds f to the "size_kb" field.
func (m *ImageMutation) AddSizeKB(f float64) {
	if m.addsize_kb != nil {
		*m.addsize_kb += f
	} else {
		m.addsize_kb = &f
	}
}

// AddedSizeKB returns the value that was added to the "size_kb" field in this mutation.
func (m *ImageMutation) AddedSizeKB() (r float64, exists bool) {
	v := m.addsize_kb
	if v == nil {
		return
	}
	return *v, true
}

// ResetSizeKB resets all changes to the "size_kb" field.
func (m *ImageMutation) ResetSizeKB() {
	m.size_kb = nil
	m.addsize_kb = nil
}

// SetUploadedAt sets the "uploaded_at" field.
func (m *ImageMutation) SetUploadedAt(t time.Time) {
	m.uploaded_at = &t
}

// UploadedAt returns the value of the "uploaded_at" field in the mutation.
func (m *ImageMutation) UploadedAt() (r time.Time, exists bool) {
	v := m.uploaded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedAt returns the old "uploaded_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldUploadedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedAt: %w", err)
	}
	return oldValue.UploadedAt, nil
}

// ResetUploadedAt resets all changes to the "uploaded_at" field.
func (m *ImageMutation) ResetUploadedAt() {
	m.uploaded_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ImageMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ImageMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ImageMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ImageMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ImageMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCommentID sets the "comment" edge to the Comment entity by id.
func (m *ImageMutation) SetCommentID(id int) {
	m.comment = &id
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *ImageMutation) ClearComment() {
	m.clearedcomment = true
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *ImageMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentID returns the "comment" edge ID in the mutation.
func (m *ImageMutation) CommentID() (id int, exists bool) {
	if m.comment != nil {
		return *m.comment, true
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *ImageMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// SetBrandID sets the "brand" edge to the Brand entity by id.
func (m *ImageMutation) SetBrandID(id int) {
	m.brand = &id
}

// ClearBrand clears the "brand" edge to the Brand entity.
func (m *ImageMutation) ClearBrand() {
	m.clearedbrand = true
}

// BrandCleared reports if the "brand" edge to the Brand entity was cleared.
func (m *ImageMutation) BrandCleared() bool {
	return m.clearedbrand
}

// BrandID returns the "brand" edge ID in the mutation.
func (m *ImageMutation) BrandID() (id int, exists bool) {
	if m.brand != nil {
		return *m.brand, true
	}
	return
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) BrandIDs() (ids []int) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *ImageMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *ImageMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ImageMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ImageMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *ImageMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ImageMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, image.FieldName)
	}
	if m._path != nil {
		fields = append(fields, image.FieldPath)
	}
	if m.caption != nil {
		fields = append(fields, image.FieldCaption)
	}
	if m.width != nil {
		fields = append(fields, image.FieldWidth)
	}
	if m.high != nil {
		fields = append(fields, image.FieldHigh)
	}
	if m.size_kb != nil {
		fields = append(fields, image.FieldSizeKB)
	}
	if m.uploaded_at != nil {
		fields = append(fields, image.FieldUploadedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldName:
		return m.Name()
	case image.FieldPath:
		return m.Path()
	case image.FieldCaption:
		return m.Caption()
	case image.FieldWidth:
		return m.Width()
	case image.FieldHigh:
		return m.High()
	case image.FieldSizeKB:
		return m.SizeKB()
	case image.FieldUploadedAt:
		return m.UploadedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldName:
		return m.OldName(ctx)
	case image.FieldPath:
		return m.OldPath(ctx)
	case image.FieldCaption:
		return m.OldCaption(ctx)
	case image.FieldWidth:
		return m.OldWidth(ctx)
	case image.FieldHigh:
		return m.OldHigh(ctx)
	case image.FieldSizeKB:
		return m.OldSizeKB(ctx)
	case image.FieldUploadedAt:
		return m.OldUploadedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case image.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case image.FieldCaption:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaption(v)
		return nil
	case image.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case image.FieldHigh:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHigh(v)
		return nil
	case image.FieldSizeKB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeKB(v)
		return nil
	case image.FieldUploadedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, image.FieldWidth)
	}
	if m.addhigh != nil {
		fields = append(fields, image.FieldHigh)
	}
	if m.addsize_kb != nil {
		fields = append(fields, image.FieldSizeKB)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case image.FieldWidth:
		return m.AddedWidth()
	case image.FieldHigh:
		return m.AddedHigh()
	case image.FieldSizeKB:
		return m.AddedSizeKB()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case image.FieldWidth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case image.FieldHigh:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHigh(v)
		return nil
	case image.FieldSizeKB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeKB(v)
		return nil
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(image.FieldCaption) {
		fields = append(fields, image.FieldCaption)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	switch name {
	case image.FieldCaption:
		m.ClearCaption()
		return nil
	}
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldName:
		m.ResetName()
		return nil
	case image.FieldPath:
		m.ResetPath()
		return nil
	case image.FieldCaption:
		m.ResetCaption()
		return nil
	case image.FieldWidth:
		m.ResetWidth()
		return nil
	case image.FieldHigh:
		m.ResetHigh()
		return nil
	case image.FieldSizeKB:
		m.ResetSizeKB()
		return nil
	case image.FieldUploadedAt:
		m.ResetUploadedAt()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, image.EdgeUser)
	}
	if m.comment != nil {
		edges = append(edges, image.EdgeComment)
	}
	if m.brand != nil {
		edges = append(edges, image.EdgeBrand)
	}
	if m.product != nil {
		edges = append(edges, image.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, image.EdgeUser)
	}
	if m.clearedcomment {
		edges = append(edges, image.EdgeComment)
	}
	if m.clearedbrand {
		edges = append(edges, image.EdgeBrand)
	}
	if m.clearedproduct {
		edges = append(edges, image.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeUser:
		return m.cleareduser
	case image.EdgeComment:
		return m.clearedcomment
	case image.EdgeBrand:
		return m.clearedbrand
	case image.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeUser:
		m.ClearUser()
		return nil
	case image.EdgeComment:
		m.ClearComment()
		return nil
	case image.EdgeBrand:
		m.ClearBrand()
		return nil
	case image.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeUser:
		m.ResetUser()
		return nil
	case image.EdgeComment:
		m.ResetComment()
		return nil
	case image.EdgeBrand:
		m.ResetBrand()
		return nil
	case image.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// LogsMutation represents an operation that mutates the Logs nodes in the graph.
type LogsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	action        *string
	_IP           *string
	agent         *string
	date          *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Logs, error)
	predicates    []predicate.Logs
}

var _ ent.Mutation = (*LogsMutation)(nil)

// logsOption allows management of the mutation configuration using functional options.
type logsOption func(*LogsMutation)

// newLogsMutation creates new mutation for the Logs entity.
func newLogsMutation(c config, op Op, opts ...logsOption) *LogsMutation {
	m := &LogsMutation{
		config:        c,
		op:            op,
		typ:           TypeLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogsID sets the ID field of the mutation.
func withLogsID(id int) logsOption {
	return func(m *LogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Logs
		)
		m.oldValue = func(ctx context.Context) (*Logs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Logs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogs sets the old Logs of the mutation.
func withLogs(node *Logs) logsOption {
	return func(m *LogsMutation) {
		m.oldValue = func(context.Context) (*Logs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Logs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAction sets the "action" field.
func (m *LogsMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *LogsMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldAction(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *LogsMutation) ClearAction() {
	m.action = nil
	m.clearedFields[logs.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *LogsMutation) ActionCleared() bool {
	_, ok := m.clearedFields[logs.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *LogsMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, logs.FieldAction)
}

// SetIP sets the "IP" field.
func (m *LogsMutation) SetIP(s string) {
	m._IP = &s
}

// IP returns the value of the "IP" field in the mutation.
func (m *LogsMutation) IP() (r string, exists bool) {
	v := m._IP
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "IP" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "IP" field.
func (m *LogsMutation) ResetIP() {
	m._IP = nil
}

// SetAgent sets the "agent" field.
func (m *LogsMutation) SetAgent(s string) {
	m.agent = &s
}

// Agent returns the value of the "agent" field in the mutation.
func (m *LogsMutation) Agent() (r string, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgent returns the old "agent" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgent: %w", err)
	}
	return oldValue.Agent, nil
}

// ResetAgent resets all changes to the "agent" field.
func (m *LogsMutation) ResetAgent() {
	m.agent = nil
}

// SetDate sets the "date" field.
func (m *LogsMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *LogsMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *LogsMutation) ResetDate() {
	m.date = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *LogsMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *LogsMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LogsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *LogsMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LogsMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LogsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the LogsMutation builder.
func (m *LogsMutation) Where(ps ...predicate.Logs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Logs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Logs).
func (m *LogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.action != nil {
		fields = append(fields, logs.FieldAction)
	}
	if m._IP != nil {
		fields = append(fields, logs.FieldIP)
	}
	if m.agent != nil {
		fields = append(fields, logs.FieldAgent)
	}
	if m.date != nil {
		fields = append(fields, logs.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldAction:
		return m.Action()
	case logs.FieldIP:
		return m.IP()
	case logs.FieldAgent:
		return m.Agent()
	case logs.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logs.FieldAction:
		return m.OldAction(ctx)
	case logs.FieldIP:
		return m.OldIP(ctx)
	case logs.FieldAgent:
		return m.OldAgent(ctx)
	case logs.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Logs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logs.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case logs.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case logs.FieldAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgent(v)
		return nil
	case logs.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Logs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logs.FieldAction) {
		fields = append(fields, logs.FieldAction)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogsMutation) ClearField(name string) error {
	switch name {
	case logs.FieldAction:
		m.ClearAction()
		return nil
	}
	return fmt.Errorf("unknown Logs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogsMutation) ResetField(name string) error {
	switch name {
	case logs.FieldAction:
		m.ResetAction()
		return nil
	case logs.FieldIP:
		m.ResetIP()
		return nil
	case logs.FieldAgent:
		m.ResetAgent()
		return nil
	case logs.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, logs.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case logs.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, logs.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogsMutation) EdgeCleared(name string) bool {
	switch name {
	case logs.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogsMutation) ClearEdge(name string) error {
	switch name {
	case logs.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Logs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogsMutation) ResetEdge(name string) error {
	switch name {
	case logs.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Logs edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	update_time    *time.Time
	clearedFields  map[string]struct{}
	product        map[int]struct{}
	removedproduct map[int]struct{}
	clearedproduct bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Order, error)
	predicates     []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *OrderMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderMutation) ResetUpdateTime() {
	m.update_time = nil
}

// AddProductIDs adds the "product" edge to the Product entity by ids.
func (m *OrderMutation) AddProductIDs(ids ...int) {
	if m.product == nil {
		m.product = make(map[int]struct{})
	}
	for i := range ids {
		m.product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *OrderMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *OrderMutation) ProductCleared() bool {
	return m.clearedproduct
}

// RemoveProductIDs removes the "product" edge to the Product entity by IDs.
func (m *OrderMutation) RemoveProductIDs(ids ...int) {
	if m.removedproduct == nil {
		m.removedproduct = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product, ids[i])
		m.removedproduct[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "product" edge to the Product entity.
func (m *OrderMutation) RemovedProductIDs() (ids []int) {
	for id := range m.removedproduct {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
func (m *OrderMutation) ProductIDs() (ids []int) {
	for id := range m.product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *OrderMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
	m.removedproduct = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *OrderMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrderMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *OrderMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, order.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, order.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreateTime:
		return m.CreateTime()
	case order.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case order.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case order.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case order.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, order.EdgeProduct)
	}
	if m.user != nil {
		edges = append(edges, order.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.product))
		for id := range m.product {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproduct != nil {
		edges = append(edges, order.EdgeProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removedproduct))
		for id := range m.removedproduct {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, order.EdgeProduct)
	}
	if m.cleareduser {
		edges = append(edges, order.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeProduct:
		return m.clearedproduct
	case order.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeProduct:
		m.ResetProduct()
		return nil
	case order.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	name            *string
	description     *string
	review          *string
	rating          *float64
	addrating       *float64
	rating_count    *int32
	addrating_count *int32
	price           *int32
	addprice        *int32
	quantity        *int32
	addquantity     *int32
	available       *bool
	clearedFields   map[string]struct{}
	values          map[int]struct{}
	removedvalues   map[int]struct{}
	clearedvalues   bool
	comment         map[int]struct{}
	removedcomment  map[int]struct{}
	clearedcomment  bool
	image           map[int]struct{}
	removedimage    map[int]struct{}
	clearedimage    bool
	_order          map[int]struct{}
	removed_order   map[int]struct{}
	cleared_order   bool
	brand           *int
	clearedbrand    bool
	done            bool
	oldValue        func(context.Context) (*Product, error)
	predicates      []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ProductMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
}

// SetReview sets the "review" field.
func (m *ProductMutation) SetReview(s string) {
	m.review = &s
}

// Review returns the value of the "review" field in the mutation.
func (m *ProductMutation) Review() (r string, exists bool) {
	v := m.review
	if v == nil {
		return
	}
	return *v, true
}

// OldReview returns the old "review" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldReview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReview: %w", err)
	}
	return oldValue.Review, nil
}

// ResetReview resets all changes to the "review" field.
func (m *ProductMutation) ResetReview() {
	m.review = nil
}

// SetRating sets the "rating" field.
func (m *ProductMutation) SetRating(f float64) {
	m.rating = &f
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *ProductMutation) Rating() (r float64, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds f to the "rating" field.
func (m *ProductMutation) AddRating(f float64) {
	if m.addrating != nil {
		*m.addrating += f
	} else {
		m.addrating = &f
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *ProductMutation) AddedRating() (r float64, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *ProductMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetRatingCount sets the "rating_count" field.
func (m *ProductMutation) SetRatingCount(i int32) {
	m.rating_count = &i
	m.addrating_count = nil
}

// RatingCount returns the value of the "rating_count" field in the mutation.
func (m *ProductMutation) RatingCount() (r int32, exists bool) {
	v := m.rating_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingCount returns the old "rating_count" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldRatingCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingCount: %w", err)
	}
	return oldValue.RatingCount, nil
}

// AddRatingCount adds i to the "rating_count" field.
func (m *ProductMutation) AddRatingCount(i int32) {
	if m.addrating_count != nil {
		*m.addrating_count += i
	} else {
		m.addrating_count = &i
	}
}

// AddedRatingCount returns the value that was added to the "rating_count" field in this mutation.
func (m *ProductMutation) AddedRatingCount() (r int32, exists bool) {
	v := m.addrating_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatingCount resets all changes to the "rating_count" field.
func (m *ProductMutation) ResetRatingCount() {
	m.rating_count = nil
	m.addrating_count = nil
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(i int32) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r int32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *ProductMutation) AddPrice(i int32) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r int32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetQuantity sets the "quantity" field.
func (m *ProductMutation) SetQuantity(i int32) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ProductMutation) Quantity() (r int32, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldQuantity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *ProductMutation) AddQuantity(i int32) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ProductMutation) AddedQuantity() (r int32, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ProductMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetAvailable sets the "available" field.
func (m *ProductMutation) SetAvailable(b bool) {
	m.available = &b
}

// Available returns the value of the "available" field in the mutation.
func (m *ProductMutation) Available() (r bool, exists bool) {
	v := m.available
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailable returns the old "available" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAvailable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailable: %w", err)
	}
	return oldValue.Available, nil
}

// ResetAvailable resets all changes to the "available" field.
func (m *ProductMutation) ResetAvailable() {
	m.available = nil
}

// AddValueIDs adds the "values" edge to the AttributeValue entity by ids.
func (m *ProductMutation) AddValueIDs(ids ...int) {
	if m.values == nil {
		m.values = make(map[int]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the AttributeValue entity.
func (m *ProductMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the AttributeValue entity was cleared.
func (m *ProductMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the AttributeValue entity by IDs.
func (m *ProductMutation) RemoveValueIDs(ids ...int) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the AttributeValue entity.
func (m *ProductMutation) RemovedValuesIDs() (ids []int) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *ProductMutation) ValuesIDs() (ids []int) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *ProductMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// AddCommentIDs adds the "comment" edge to the Comment entity by ids.
func (m *ProductMutation) AddCommentIDs(ids ...int) {
	if m.comment == nil {
		m.comment = make(map[int]struct{})
	}
	for i := range ids {
		m.comment[ids[i]] = struct{}{}
	}
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *ProductMutation) ClearComment() {
	m.clearedcomment = true
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *ProductMutation) CommentCleared() bool {
	return m.clearedcomment
}

// RemoveCommentIDs removes the "comment" edge to the Comment entity by IDs.
func (m *ProductMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomment == nil {
		m.removedcomment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comment, ids[i])
		m.removedcomment[ids[i]] = struct{}{}
	}
}

// RemovedComment returns the removed IDs of the "comment" edge to the Comment entity.
func (m *ProductMutation) RemovedCommentIDs() (ids []int) {
	for id := range m.removedcomment {
		ids = append(ids, id)
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
func (m *ProductMutation) CommentIDs() (ids []int) {
	for id := range m.comment {
		ids = append(ids, id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *ProductMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
	m.removedcomment = nil
}

// AddImageIDs adds the "image" edge to the Image entity by ids.
func (m *ProductMutation) AddImageIDs(ids ...int) {
	if m.image == nil {
		m.image = make(map[int]struct{})
	}
	for i := range ids {
		m.image[ids[i]] = struct{}{}
	}
}

// ClearImage clears the "image" edge to the Image entity.
func (m *ProductMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *ProductMutation) ImageCleared() bool {
	return m.clearedimage
}

// RemoveImageIDs removes the "image" edge to the Image entity by IDs.
func (m *ProductMutation) RemoveImageIDs(ids ...int) {
	if m.removedimage == nil {
		m.removedimage = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.image, ids[i])
		m.removedimage[ids[i]] = struct{}{}
	}
}

// RemovedImage returns the removed IDs of the "image" edge to the Image entity.
func (m *ProductMutation) RemovedImageIDs() (ids []int) {
	for id := range m.removedimage {
		ids = append(ids, id)
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
func (m *ProductMutation) ImageIDs() (ids []int) {
	for id := range m.image {
		ids = append(ids, id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *ProductMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
	m.removedimage = nil
}

// AddOrderIDs adds the "order" edge to the Order entity by ids.
func (m *ProductMutation) AddOrderIDs(ids ...int) {
	if m._order == nil {
		m._order = make(map[int]struct{})
	}
	for i := range ids {
		m._order[ids[i]] = struct{}{}
	}
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *ProductMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *ProductMutation) OrderCleared() bool {
	return m.cleared_order
}

// RemoveOrderIDs removes the "order" edge to the Order entity by IDs.
func (m *ProductMutation) RemoveOrderIDs(ids ...int) {
	if m.removed_order == nil {
		m.removed_order = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._order, ids[i])
		m.removed_order[ids[i]] = struct{}{}
	}
}

// RemovedOrder returns the removed IDs of the "order" edge to the Order entity.
func (m *ProductMutation) RemovedOrderIDs() (ids []int) {
	for id := range m.removed_order {
		ids = append(ids, id)
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
func (m *ProductMutation) OrderIDs() (ids []int) {
	for id := range m._order {
		ids = append(ids, id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *ProductMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
	m.removed_order = nil
}

// SetBrandID sets the "brand" edge to the Brand entity by id.
func (m *ProductMutation) SetBrandID(id int) {
	m.brand = &id
}

// ClearBrand clears the "brand" edge to the Brand entity.
func (m *ProductMutation) ClearBrand() {
	m.clearedbrand = true
}

// BrandCleared reports if the "brand" edge to the Brand entity was cleared.
func (m *ProductMutation) BrandCleared() bool {
	return m.clearedbrand
}

// BrandID returns the "brand" edge ID in the mutation.
func (m *ProductMutation) BrandID() (id int, exists bool) {
	if m.brand != nil {
		return *m.brand, true
	}
	return
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) BrandIDs() (ids []int) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *ProductMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, product.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, product.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.review != nil {
		fields = append(fields, product.FieldReview)
	}
	if m.rating != nil {
		fields = append(fields, product.FieldRating)
	}
	if m.rating_count != nil {
		fields = append(fields, product.FieldRatingCount)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.quantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	if m.available != nil {
		fields = append(fields, product.FieldAvailable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreateTime:
		return m.CreateTime()
	case product.FieldUpdateTime:
		return m.UpdateTime()
	case product.FieldName:
		return m.Name()
	case product.FieldDescription:
		return m.Description()
	case product.FieldReview:
		return m.Review()
	case product.FieldRating:
		return m.Rating()
	case product.FieldRatingCount:
		return m.RatingCount()
	case product.FieldPrice:
		return m.Price()
	case product.FieldQuantity:
		return m.Quantity()
	case product.FieldAvailable:
		return m.Available()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case product.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldReview:
		return m.OldReview(ctx)
	case product.FieldRating:
		return m.OldRating(ctx)
	case product.FieldRatingCount:
		return m.OldRatingCount(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldQuantity:
		return m.OldQuantity(ctx)
	case product.FieldAvailable:
		return m.OldAvailable(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case product.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldReview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReview(v)
		return nil
	case product.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case product.FieldRatingCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingCount(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case product.FieldAvailable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailable(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addrating != nil {
		fields = append(fields, product.FieldRating)
	}
	if m.addrating_count != nil {
		fields = append(fields, product.FieldRatingCount)
	}
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.addquantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldRating:
		return m.AddedRating()
	case product.FieldRatingCount:
		return m.AddedRatingCount()
	case product.FieldPrice:
		return m.AddedPrice()
	case product.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	case product.FieldRatingCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatingCount(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case product.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldReview:
		m.ResetReview()
		return nil
	case product.FieldRating:
		m.ResetRating()
		return nil
	case product.FieldRatingCount:
		m.ResetRatingCount()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldQuantity:
		m.ResetQuantity()
		return nil
	case product.FieldAvailable:
		m.ResetAvailable()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.values != nil {
		edges = append(edges, product.EdgeValues)
	}
	if m.comment != nil {
		edges = append(edges, product.EdgeComment)
	}
	if m.image != nil {
		edges = append(edges, product.EdgeImage)
	}
	if m._order != nil {
		edges = append(edges, product.EdgeOrder)
	}
	if m.brand != nil {
		edges = append(edges, product.EdgeBrand)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeComment:
		ids := make([]ent.Value, 0, len(m.comment))
		for id := range m.comment {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeImage:
		ids := make([]ent.Value, 0, len(m.image))
		for id := range m.image {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeOrder:
		ids := make([]ent.Value, 0, len(m._order))
		for id := range m._order {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedvalues != nil {
		edges = append(edges, product.EdgeValues)
	}
	if m.removedcomment != nil {
		edges = append(edges, product.EdgeComment)
	}
	if m.removedimage != nil {
		edges = append(edges, product.EdgeImage)
	}
	if m.removed_order != nil {
		edges = append(edges, product.EdgeOrder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeComment:
		ids := make([]ent.Value, 0, len(m.removedcomment))
		for id := range m.removedcomment {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeImage:
		ids := make([]ent.Value, 0, len(m.removedimage))
		for id := range m.removedimage {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.removed_order))
		for id := range m.removed_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedvalues {
		edges = append(edges, product.EdgeValues)
	}
	if m.clearedcomment {
		edges = append(edges, product.EdgeComment)
	}
	if m.clearedimage {
		edges = append(edges, product.EdgeImage)
	}
	if m.cleared_order {
		edges = append(edges, product.EdgeOrder)
	}
	if m.clearedbrand {
		edges = append(edges, product.EdgeBrand)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeValues:
		return m.clearedvalues
	case product.EdgeComment:
		return m.clearedcomment
	case product.EdgeImage:
		return m.clearedimage
	case product.EdgeOrder:
		return m.cleared_order
	case product.EdgeBrand:
		return m.clearedbrand
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeBrand:
		m.ClearBrand()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeValues:
		m.ResetValues()
		return nil
	case product.EdgeComment:
		m.ResetComment()
		return nil
	case product.EdgeImage:
		m.ResetImage()
		return nil
	case product.EdgeOrder:
		m.ResetOrder()
		return nil
	case product.EdgeBrand:
		m.ResetBrand()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProsMutation represents an operation that mutates the Pros nodes in the graph.
type ProsMutation struct {
	config
	op             Op
	typ            string
	id             *int
	pro            *string
	clearedFields  map[string]struct{}
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*Pros, error)
	predicates     []predicate.Pros
}

var _ ent.Mutation = (*ProsMutation)(nil)

// prosOption allows management of the mutation configuration using functional options.
type prosOption func(*ProsMutation)

// newProsMutation creates new mutation for the Pros entity.
func newProsMutation(c config, op Op, opts ...prosOption) *ProsMutation {
	m := &ProsMutation{
		config:        c,
		op:            op,
		typ:           TypePros,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProsID sets the ID field of the mutation.
func withProsID(id int) prosOption {
	return func(m *ProsMutation) {
		var (
			err   error
			once  sync.Once
			value *Pros
		)
		m.oldValue = func(ctx context.Context) (*Pros, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pros.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPros sets the old Pros of the mutation.
func withPros(node *Pros) prosOption {
	return func(m *ProsMutation) {
		m.oldValue = func(context.Context) (*Pros, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pros.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPro sets the "pro" field.
func (m *ProsMutation) SetPro(s string) {
	m.pro = &s
}

// Pro returns the value of the "pro" field in the mutation.
func (m *ProsMutation) Pro() (r string, exists bool) {
	v := m.pro
	if v == nil {
		return
	}
	return *v, true
}

// OldPro returns the old "pro" field's value of the Pros entity.
// If the Pros object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProsMutation) OldPro(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPro is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPro requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPro: %w", err)
	}
	return oldValue.Pro, nil
}

// ResetPro resets all changes to the "pro" field.
func (m *ProsMutation) ResetPro() {
	m.pro = nil
}

// SetCommentID sets the "comment" edge to the Comment entity by id.
func (m *ProsMutation) SetCommentID(id int) {
	m.comment = &id
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *ProsMutation) ClearComment() {
	m.clearedcomment = true
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *ProsMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentID returns the "comment" edge ID in the mutation.
func (m *ProsMutation) CommentID() (id int, exists bool) {
	if m.comment != nil {
		return *m.comment, true
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *ProsMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *ProsMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the ProsMutation builder.
func (m *ProsMutation) Where(ps ...predicate.Pros) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pros, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pros).
func (m *ProsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.pro != nil {
		fields = append(fields, pros.FieldPro)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pros.FieldPro:
		return m.Pro()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pros.FieldPro:
		return m.OldPro(ctx)
	}
	return nil, fmt.Errorf("unknown Pros field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pros.FieldPro:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPro(v)
		return nil
	}
	return fmt.Errorf("unknown Pros field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pros numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pros nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProsMutation) ResetField(name string) error {
	switch name {
	case pros.FieldPro:
		m.ResetPro()
		return nil
	}
	return fmt.Errorf("unknown Pros field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.comment != nil {
		edges = append(edges, pros.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pros.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomment {
		edges = append(edges, pros.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProsMutation) EdgeCleared(name string) bool {
	switch name {
	case pros.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProsMutation) ClearEdge(name string) error {
	switch name {
	case pros.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown Pros unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProsMutation) ResetEdge(name string) error {
	switch name {
	case pros.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown Pros edge %s", name)
}

// SellerMutation represents an operation that mutates the Seller nodes in the graph.
type SellerMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	name            *string
	description     *string
	rating          *float64
	addrating       *float64
	rating_count    *int32
	addrating_count *int32
	phone           *string
	clearedFields   map[string]struct{}
	product         map[int]struct{}
	removedproduct  map[int]struct{}
	clearedproduct  bool
	category        map[int]struct{}
	removedcategory map[int]struct{}
	clearedcategory bool
	address         map[int]struct{}
	removedaddress  map[int]struct{}
	clearedaddress  bool
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Seller, error)
	predicates      []predicate.Seller
}

var _ ent.Mutation = (*SellerMutation)(nil)

// sellerOption allows management of the mutation configuration using functional options.
type sellerOption func(*SellerMutation)

// newSellerMutation creates new mutation for the Seller entity.
func newSellerMutation(c config, op Op, opts ...sellerOption) *SellerMutation {
	m := &SellerMutation{
		config:        c,
		op:            op,
		typ:           TypeSeller,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSellerID sets the ID field of the mutation.
func withSellerID(id int) sellerOption {
	return func(m *SellerMutation) {
		var (
			err   error
			once  sync.Once
			value *Seller
		)
		m.oldValue = func(ctx context.Context) (*Seller, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Seller.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeller sets the old Seller of the mutation.
func withSeller(node *Seller) sellerOption {
	return func(m *SellerMutation) {
		m.oldValue = func(context.Context) (*Seller, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SellerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SellerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SellerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SellerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Seller.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SellerMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SellerMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Seller entity.
// If the Seller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SellerMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SellerMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SellerMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Seller entity.
// If the Seller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SellerMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *SellerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SellerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Seller entity.
// If the Seller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SellerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SellerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SellerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Seller entity.
// If the Seller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SellerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[seller.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SellerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[seller.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SellerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, seller.FieldDescription)
}

// SetRating sets the "rating" field.
func (m *SellerMutation) SetRating(f float64) {
	m.rating = &f
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *SellerMutation) Rating() (r float64, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Seller entity.
// If the Seller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerMutation) OldRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds f to the "rating" field.
func (m *SellerMutation) AddRating(f float64) {
	if m.addrating != nil {
		*m.addrating += f
	} else {
		m.addrating = &f
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *SellerMutation) AddedRating() (r float64, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *SellerMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetRatingCount sets the "rating_count" field.
func (m *SellerMutation) SetRatingCount(i int32) {
	m.rating_count = &i
	m.addrating_count = nil
}

// RatingCount returns the value of the "rating_count" field in the mutation.
func (m *SellerMutation) RatingCount() (r int32, exists bool) {
	v := m.rating_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingCount returns the old "rating_count" field's value of the Seller entity.
// If the Seller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerMutation) OldRatingCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingCount: %w", err)
	}
	return oldValue.RatingCount, nil
}

// AddRatingCount adds i to the "rating_count" field.
func (m *SellerMutation) AddRatingCount(i int32) {
	if m.addrating_count != nil {
		*m.addrating_count += i
	} else {
		m.addrating_count = &i
	}
}

// AddedRatingCount returns the value that was added to the "rating_count" field in this mutation.
func (m *SellerMutation) AddedRatingCount() (r int32, exists bool) {
	v := m.addrating_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatingCount resets all changes to the "rating_count" field.
func (m *SellerMutation) ResetRatingCount() {
	m.rating_count = nil
	m.addrating_count = nil
}

// SetPhone sets the "phone" field.
func (m *SellerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SellerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Seller entity.
// If the Seller object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SellerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *SellerMutation) ResetPhone() {
	m.phone = nil
}

// AddProductIDs adds the "product" edge to the Product entity by ids.
func (m *SellerMutation) AddProductIDs(ids ...int) {
	if m.product == nil {
		m.product = make(map[int]struct{})
	}
	for i := range ids {
		m.product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *SellerMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *SellerMutation) ProductCleared() bool {
	return m.clearedproduct
}

// RemoveProductIDs removes the "product" edge to the Product entity by IDs.
func (m *SellerMutation) RemoveProductIDs(ids ...int) {
	if m.removedproduct == nil {
		m.removedproduct = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product, ids[i])
		m.removedproduct[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "product" edge to the Product entity.
func (m *SellerMutation) RemovedProductIDs() (ids []int) {
	for id := range m.removedproduct {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
func (m *SellerMutation) ProductIDs() (ids []int) {
	for id := range m.product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *SellerMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
	m.removedproduct = nil
}

// AddCategoryIDs adds the "category" edge to the Category entity by ids.
func (m *SellerMutation) AddCategoryIDs(ids ...int) {
	if m.category == nil {
		m.category = make(map[int]struct{})
	}
	for i := range ids {
		m.category[ids[i]] = struct{}{}
	}
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *SellerMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *SellerMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// RemoveCategoryIDs removes the "category" edge to the Category entity by IDs.
func (m *SellerMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategory == nil {
		m.removedcategory = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.category, ids[i])
		m.removedcategory[ids[i]] = struct{}{}
	}
}

// RemovedCategory returns the removed IDs of the "category" edge to the Category entity.
func (m *SellerMutation) RemovedCategoryIDs() (ids []int) {
	for id := range m.removedcategory {
		ids = append(ids, id)
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
func (m *SellerMutation) CategoryIDs() (ids []int) {
	for id := range m.category {
		ids = append(ids, id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *SellerMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
	m.removedcategory = nil
}

// AddAddresIDs adds the "address" edge to the Address entity by ids.
func (m *SellerMutation) AddAddresIDs(ids ...int) {
	if m.address == nil {
		m.address = make(map[int]struct{})
	}
	for i := range ids {
		m.address[ids[i]] = struct{}{}
	}
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *SellerMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *SellerMutation) AddressCleared() bool {
	return m.clearedaddress
}

// RemoveAddresIDs removes the "address" edge to the Address entity by IDs.
func (m *SellerMutation) RemoveAddresIDs(ids ...int) {
	if m.removedaddress == nil {
		m.removedaddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.address, ids[i])
		m.removedaddress[ids[i]] = struct{}{}
	}
}

// RemovedAddress returns the removed IDs of the "address" edge to the Address entity.
func (m *SellerMutation) RemovedAddressIDs() (ids []int) {
	for id := range m.removedaddress {
		ids = append(ids, id)
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
func (m *SellerMutation) AddressIDs() (ids []int) {
	for id := range m.address {
		ids = append(ids, id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *SellerMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
	m.removedaddress = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SellerMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SellerMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SellerMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SellerMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SellerMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SellerMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SellerMutation builder.
func (m *SellerMutation) Where(ps ...predicate.Seller) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SellerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SellerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Seller, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SellerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SellerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Seller).
func (m *SellerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SellerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, seller.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, seller.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, seller.FieldName)
	}
	if m.description != nil {
		fields = append(fields, seller.FieldDescription)
	}
	if m.rating != nil {
		fields = append(fields, seller.FieldRating)
	}
	if m.rating_count != nil {
		fields = append(fields, seller.FieldRatingCount)
	}
	if m.phone != nil {
		fields = append(fields, seller.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SellerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seller.FieldCreateTime:
		return m.CreateTime()
	case seller.FieldUpdateTime:
		return m.UpdateTime()
	case seller.FieldName:
		return m.Name()
	case seller.FieldDescription:
		return m.Description()
	case seller.FieldRating:
		return m.Rating()
	case seller.FieldRatingCount:
		return m.RatingCount()
	case seller.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SellerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seller.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case seller.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case seller.FieldName:
		return m.OldName(ctx)
	case seller.FieldDescription:
		return m.OldDescription(ctx)
	case seller.FieldRating:
		return m.OldRating(ctx)
	case seller.FieldRatingCount:
		return m.OldRatingCount(ctx)
	case seller.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Seller field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seller.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case seller.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case seller.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case seller.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case seller.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case seller.FieldRatingCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingCount(v)
		return nil
	case seller.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Seller field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SellerMutation) AddedFields() []string {
	var fields []string
	if m.addrating != nil {
		fields = append(fields, seller.FieldRating)
	}
	if m.addrating_count != nil {
		fields = append(fields, seller.FieldRatingCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SellerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case seller.FieldRating:
		return m.AddedRating()
	case seller.FieldRatingCount:
		return m.AddedRatingCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SellerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case seller.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	case seller.FieldRatingCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatingCount(v)
		return nil
	}
	return fmt.Errorf("unknown Seller numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SellerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(seller.FieldDescription) {
		fields = append(fields, seller.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SellerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SellerMutation) ClearField(name string) error {
	switch name {
	case seller.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Seller nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SellerMutation) ResetField(name string) error {
	switch name {
	case seller.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case seller.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case seller.FieldName:
		m.ResetName()
		return nil
	case seller.FieldDescription:
		m.ResetDescription()
		return nil
	case seller.FieldRating:
		m.ResetRating()
		return nil
	case seller.FieldRatingCount:
		m.ResetRatingCount()
		return nil
	case seller.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Seller field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SellerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.product != nil {
		edges = append(edges, seller.EdgeProduct)
	}
	if m.category != nil {
		edges = append(edges, seller.EdgeCategory)
	}
	if m.address != nil {
		edges = append(edges, seller.EdgeAddress)
	}
	if m.user != nil {
		edges = append(edges, seller.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SellerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seller.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.product))
		for id := range m.product {
			ids = append(ids, id)
		}
		return ids
	case seller.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.category))
		for id := range m.category {
			ids = append(ids, id)
		}
		return ids
	case seller.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.address))
		for id := range m.address {
			ids = append(ids, id)
		}
		return ids
	case seller.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SellerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedproduct != nil {
		edges = append(edges, seller.EdgeProduct)
	}
	if m.removedcategory != nil {
		edges = append(edges, seller.EdgeCategory)
	}
	if m.removedaddress != nil {
		edges = append(edges, seller.EdgeAddress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SellerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case seller.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removedproduct))
		for id := range m.removedproduct {
			ids = append(ids, id)
		}
		return ids
	case seller.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.removedcategory))
		for id := range m.removedcategory {
			ids = append(ids, id)
		}
		return ids
	case seller.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.removedaddress))
		for id := range m.removedaddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SellerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproduct {
		edges = append(edges, seller.EdgeProduct)
	}
	if m.clearedcategory {
		edges = append(edges, seller.EdgeCategory)
	}
	if m.clearedaddress {
		edges = append(edges, seller.EdgeAddress)
	}
	if m.cleareduser {
		edges = append(edges, seller.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SellerMutation) EdgeCleared(name string) bool {
	switch name {
	case seller.EdgeProduct:
		return m.clearedproduct
	case seller.EdgeCategory:
		return m.clearedcategory
	case seller.EdgeAddress:
		return m.clearedaddress
	case seller.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SellerMutation) ClearEdge(name string) error {
	switch name {
	case seller.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Seller unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SellerMutation) ResetEdge(name string) error {
	switch name {
	case seller.EdgeProduct:
		m.ResetProduct()
		return nil
	case seller.EdgeCategory:
		m.ResetCategory()
		return nil
	case seller.EdgeAddress:
		m.ResetAddress()
		return nil
	case seller.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Seller edge %s", name)
}

// SubCategoryMutation represents an operation that mutates the SubCategory nodes in the graph.
type SubCategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	name            *string
	description     *string
	clearedFields   map[string]struct{}
	category        *int
	clearedcategory bool
	done            bool
	oldValue        func(context.Context) (*SubCategory, error)
	predicates      []predicate.SubCategory
}

var _ ent.Mutation = (*SubCategoryMutation)(nil)

// subcategoryOption allows management of the mutation configuration using functional options.
type subcategoryOption func(*SubCategoryMutation)

// newSubCategoryMutation creates new mutation for the SubCategory entity.
func newSubCategoryMutation(c config, op Op, opts ...subcategoryOption) *SubCategoryMutation {
	m := &SubCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSubCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubCategoryID sets the ID field of the mutation.
func withSubCategoryID(id int) subcategoryOption {
	return func(m *SubCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SubCategory
		)
		m.oldValue = func(ctx context.Context) (*SubCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubCategory sets the old SubCategory of the mutation.
func withSubCategory(node *SubCategory) subcategoryOption {
	return func(m *SubCategoryMutation) {
		m.oldValue = func(context.Context) (*SubCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SubCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SubCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SubCategory entity.
// If the SubCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SubCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SubCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SubCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SubCategory entity.
// If the SubCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SubCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *SubCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SubCategory entity.
// If the SubCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SubCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SubCategory entity.
// If the SubCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SubCategoryMutation) ResetDescription() {
	m.description = nil
}

// SetCategoryID sets the "category" edge to the Category entity by id.
func (m *SubCategoryMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *SubCategoryMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *SubCategoryMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *SubCategoryMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *SubCategoryMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *SubCategoryMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the SubCategoryMutation builder.
func (m *SubCategoryMutation) Where(ps ...predicate.SubCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubCategory).
func (m *SubCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubCategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, subcategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, subcategory.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, subcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, subcategory.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subcategory.FieldCreateTime:
		return m.CreateTime()
	case subcategory.FieldUpdateTime:
		return m.UpdateTime()
	case subcategory.FieldName:
		return m.Name()
	case subcategory.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subcategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case subcategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case subcategory.FieldName:
		return m.OldName(ctx)
	case subcategory.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown SubCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subcategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case subcategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case subcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown SubCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubCategoryMutation) ResetField(name string) error {
	switch name {
	case subcategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case subcategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case subcategory.FieldName:
		m.ResetName()
		return nil
	case subcategory.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown SubCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.category != nil {
		edges = append(edges, subcategory.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subcategory.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcategory {
		edges = append(edges, subcategory.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case subcategory.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubCategoryMutation) ClearEdge(name string) error {
	switch name {
	case subcategory.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown SubCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubCategoryMutation) ResetEdge(name string) error {
	switch name {
	case subcategory.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown SubCategory edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	update_time    *time.Time
	username       *string
	password       *[]byte
	first_name     *string
	last_name      *string
	email          *string
	phone          *string
	is_seller      *bool
	clearedFields  map[string]struct{}
	comment        map[int]struct{}
	removedcomment map[int]struct{}
	clearedcomment bool
	image          map[int]struct{}
	removedimage   map[int]struct{}
	clearedimage   bool
	seller         map[int]struct{}
	removedseller  map[int]struct{}
	clearedseller  bool
	_order         map[int]struct{}
	removed_order  map[int]struct{}
	cleared_order  bool
	logs           map[int]struct{}
	removedlogs    map[int]struct{}
	clearedlogs    bool
	address        map[int]struct{}
	removedaddress map[int]struct{}
	clearedaddress bool
	done           bool
	oldValue       func(context.Context) (*User, error)
	predicates     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetIsSeller sets the "is_seller" field.
func (m *UserMutation) SetIsSeller(b bool) {
	m.is_seller = &b
}

// IsSeller returns the value of the "is_seller" field in the mutation.
func (m *UserMutation) IsSeller() (r bool, exists bool) {
	v := m.is_seller
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSeller returns the old "is_seller" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsSeller(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSeller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSeller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSeller: %w", err)
	}
	return oldValue.IsSeller, nil
}

// ResetIsSeller resets all changes to the "is_seller" field.
func (m *UserMutation) ResetIsSeller() {
	m.is_seller = nil
}

// AddCommentIDs adds the "comment" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...int) {
	if m.comment == nil {
		m.comment = make(map[int]struct{})
	}
	for i := range ids {
		m.comment[ids[i]] = struct{}{}
	}
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *UserMutation) ClearComment() {
	m.clearedcomment = true
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *UserMutation) CommentCleared() bool {
	return m.clearedcomment
}

// RemoveCommentIDs removes the "comment" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomment == nil {
		m.removedcomment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comment, ids[i])
		m.removedcomment[ids[i]] = struct{}{}
	}
}

// RemovedComment returns the removed IDs of the "comment" edge to the Comment entity.
func (m *UserMutation) RemovedCommentIDs() (ids []int) {
	for id := range m.removedcomment {
		ids = append(ids, id)
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
func (m *UserMutation) CommentIDs() (ids []int) {
	for id := range m.comment {
		ids = append(ids, id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *UserMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
	m.removedcomment = nil
}

// AddImageIDs adds the "image" edge to the Image entity by ids.
func (m *UserMutation) AddImageIDs(ids ...int) {
	if m.image == nil {
		m.image = make(map[int]struct{})
	}
	for i := range ids {
		m.image[ids[i]] = struct{}{}
	}
}

// ClearImage clears the "image" edge to the Image entity.
func (m *UserMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *UserMutation) ImageCleared() bool {
	return m.clearedimage
}

// RemoveImageIDs removes the "image" edge to the Image entity by IDs.
func (m *UserMutation) RemoveImageIDs(ids ...int) {
	if m.removedimage == nil {
		m.removedimage = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.image, ids[i])
		m.removedimage[ids[i]] = struct{}{}
	}
}

// RemovedImage returns the removed IDs of the "image" edge to the Image entity.
func (m *UserMutation) RemovedImageIDs() (ids []int) {
	for id := range m.removedimage {
		ids = append(ids, id)
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
func (m *UserMutation) ImageIDs() (ids []int) {
	for id := range m.image {
		ids = append(ids, id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *UserMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
	m.removedimage = nil
}

// AddSellerIDs adds the "seller" edge to the Seller entity by ids.
func (m *UserMutation) AddSellerIDs(ids ...int) {
	if m.seller == nil {
		m.seller = make(map[int]struct{})
	}
	for i := range ids {
		m.seller[ids[i]] = struct{}{}
	}
}

// ClearSeller clears the "seller" edge to the Seller entity.
func (m *UserMutation) ClearSeller() {
	m.clearedseller = true
}

// SellerCleared reports if the "seller" edge to the Seller entity was cleared.
func (m *UserMutation) SellerCleared() bool {
	return m.clearedseller
}

// RemoveSellerIDs removes the "seller" edge to the Seller entity by IDs.
func (m *UserMutation) RemoveSellerIDs(ids ...int) {
	if m.removedseller == nil {
		m.removedseller = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.seller, ids[i])
		m.removedseller[ids[i]] = struct{}{}
	}
}

// RemovedSeller returns the removed IDs of the "seller" edge to the Seller entity.
func (m *UserMutation) RemovedSellerIDs() (ids []int) {
	for id := range m.removedseller {
		ids = append(ids, id)
	}
	return
}

// SellerIDs returns the "seller" edge IDs in the mutation.
func (m *UserMutation) SellerIDs() (ids []int) {
	for id := range m.seller {
		ids = append(ids, id)
	}
	return
}

// ResetSeller resets all changes to the "seller" edge.
func (m *UserMutation) ResetSeller() {
	m.seller = nil
	m.clearedseller = false
	m.removedseller = nil
}

// AddOrderIDs adds the "order" edge to the Order entity by ids.
func (m *UserMutation) AddOrderIDs(ids ...int) {
	if m._order == nil {
		m._order = make(map[int]struct{})
	}
	for i := range ids {
		m._order[ids[i]] = struct{}{}
	}
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *UserMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *UserMutation) OrderCleared() bool {
	return m.cleared_order
}

// RemoveOrderIDs removes the "order" edge to the Order entity by IDs.
func (m *UserMutation) RemoveOrderIDs(ids ...int) {
	if m.removed_order == nil {
		m.removed_order = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._order, ids[i])
		m.removed_order[ids[i]] = struct{}{}
	}
}

// RemovedOrder returns the removed IDs of the "order" edge to the Order entity.
func (m *UserMutation) RemovedOrderIDs() (ids []int) {
	for id := range m.removed_order {
		ids = append(ids, id)
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
func (m *UserMutation) OrderIDs() (ids []int) {
	for id := range m._order {
		ids = append(ids, id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *UserMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
	m.removed_order = nil
}

// AddLogIDs adds the "logs" edge to the Logs entity by ids.
func (m *UserMutation) AddLogIDs(ids ...int) {
	if m.logs == nil {
		m.logs = make(map[int]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the Logs entity.
func (m *UserMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the Logs entity was cleared.
func (m *UserMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the Logs entity by IDs.
func (m *UserMutation) RemoveLogIDs(ids ...int) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the Logs entity.
func (m *UserMutation) RemovedLogsIDs() (ids []int) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *UserMutation) LogsIDs() (ids []int) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *UserMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddAddresIDs adds the "address" edge to the Address entity by ids.
func (m *UserMutation) AddAddresIDs(ids ...int) {
	if m.address == nil {
		m.address = make(map[int]struct{})
	}
	for i := range ids {
		m.address[ids[i]] = struct{}{}
	}
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *UserMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *UserMutation) AddressCleared() bool {
	return m.clearedaddress
}

// RemoveAddresIDs removes the "address" edge to the Address entity by IDs.
func (m *UserMutation) RemoveAddresIDs(ids ...int) {
	if m.removedaddress == nil {
		m.removedaddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.address, ids[i])
		m.removedaddress[ids[i]] = struct{}{}
	}
}

// RemovedAddress returns the removed IDs of the "address" edge to the Address entity.
func (m *UserMutation) RemovedAddressIDs() (ids []int) {
	for id := range m.removedaddress {
		ids = append(ids, id)
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
func (m *UserMutation) AddressIDs() (ids []int) {
	for id := range m.address {
		ids = append(ids, id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *UserMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
	m.removedaddress = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.is_seller != nil {
		fields = append(fields, user.FieldIsSeller)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldIsSeller:
		return m.IsSeller()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldIsSeller:
		return m.OldIsSeller(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldIsSeller:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSeller(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldIsSeller:
		m.ResetIsSeller()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.comment != nil {
		edges = append(edges, user.EdgeComment)
	}
	if m.image != nil {
		edges = append(edges, user.EdgeImage)
	}
	if m.seller != nil {
		edges = append(edges, user.EdgeSeller)
	}
	if m._order != nil {
		edges = append(edges, user.EdgeOrder)
	}
	if m.logs != nil {
		edges = append(edges, user.EdgeLogs)
	}
	if m.address != nil {
		edges = append(edges, user.EdgeAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeComment:
		ids := make([]ent.Value, 0, len(m.comment))
		for id := range m.comment {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImage:
		ids := make([]ent.Value, 0, len(m.image))
		for id := range m.image {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSeller:
		ids := make([]ent.Value, 0, len(m.seller))
		for id := range m.seller {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrder:
		ids := make([]ent.Value, 0, len(m._order))
		for id := range m._order {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.address))
		for id := range m.address {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcomment != nil {
		edges = append(edges, user.EdgeComment)
	}
	if m.removedimage != nil {
		edges = append(edges, user.EdgeImage)
	}
	if m.removedseller != nil {
		edges = append(edges, user.EdgeSeller)
	}
	if m.removed_order != nil {
		edges = append(edges, user.EdgeOrder)
	}
	if m.removedlogs != nil {
		edges = append(edges, user.EdgeLogs)
	}
	if m.removedaddress != nil {
		edges = append(edges, user.EdgeAddress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeComment:
		ids := make([]ent.Value, 0, len(m.removedcomment))
		for id := range m.removedcomment {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImage:
		ids := make([]ent.Value, 0, len(m.removedimage))
		for id := range m.removedimage {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSeller:
		ids := make([]ent.Value, 0, len(m.removedseller))
		for id := range m.removedseller {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.removed_order))
		for id := range m.removed_order {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.removedaddress))
		for id := range m.removedaddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcomment {
		edges = append(edges, user.EdgeComment)
	}
	if m.clearedimage {
		edges = append(edges, user.EdgeImage)
	}
	if m.clearedseller {
		edges = append(edges, user.EdgeSeller)
	}
	if m.cleared_order {
		edges = append(edges, user.EdgeOrder)
	}
	if m.clearedlogs {
		edges = append(edges, user.EdgeLogs)
	}
	if m.clearedaddress {
		edges = append(edges, user.EdgeAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeComment:
		return m.clearedcomment
	case user.EdgeImage:
		return m.clearedimage
	case user.EdgeSeller:
		return m.clearedseller
	case user.EdgeOrder:
		return m.cleared_order
	case user.EdgeLogs:
		return m.clearedlogs
	case user.EdgeAddress:
		return m.clearedaddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeComment:
		m.ResetComment()
		return nil
	case user.EdgeImage:
		m.ResetImage()
		return nil
	case user.EdgeSeller:
		m.ResetSeller()
		return nil
	case user.EdgeOrder:
		m.ResetOrder()
		return nil
	case user.EdgeLogs:
		m.ResetLogs()
		return nil
	case user.EdgeAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
